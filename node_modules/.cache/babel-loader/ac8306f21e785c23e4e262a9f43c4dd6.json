{"ast":null,"code":"/*\r\n  Copyright (c) 2015 Jean-Marc VIGLINO,\r\n  released under the CeCILL-B license (http://www.cecill.info/).\r\n\r\n  ol_layer_AnimatedCluster is a vector layer that animate cluster\r\n*/\nimport ol_ext_inherits from '../util/ext';\nimport ol_layer_Vector from 'ol/layer/Vector';\nimport ol_source_Vector from 'ol/source/Vector';\nimport ol_Feature from 'ol/Feature';\nimport { easeOut as ol_easing_easeOut } from 'ol/easing';\nimport { buffer as ol_extent_buffer } from 'ol/extent';\nimport ol_geom_Point from 'ol/geom/Point';\nimport ol_render_getVectorContext from '../util/getVectorContext';\n/**\r\n *  A vector layer for animated cluster\r\n * @constructor \r\n * @extends {ol.layer.Vector}\r\n * @param {olx.layer.AnimatedClusterOptions=} options extend olx.layer.Options\r\n *  @param {Number} options.animationDuration animation duration in ms, default is 700ms \r\n *  @param {ol.easingFunction} animationMethod easing method to use, default ol.easing.easeOut\r\n */\n\nvar ol_layer_AnimatedCluster = function ol_layer_AnimatedCluster(opt_options) {\n  var options = opt_options || {};\n  ol_layer_Vector.call(this, options);\n  this.oldcluster = new ol_source_Vector();\n  this.clusters = [];\n  this.animation = {\n    start: false\n  };\n  this.set('animationDuration', typeof options.animationDuration == 'number' ? options.animationDuration : 700);\n  this.set('animationMethod', options.animationMethod || ol_easing_easeOut); // Save cluster before change\n\n  this.getSource().on('change', this.saveCluster.bind(this)); // Animate the cluster\n\n  this.on(['precompose', 'prerender'], this.animate.bind(this));\n  this.on(['postcompose', 'postrender'], this.postanimate.bind(this));\n};\n\nol_ext_inherits(ol_layer_AnimatedCluster, ol_layer_Vector);\n/** save cluster features before change\r\n * @private\r\n */\n\nol_layer_AnimatedCluster.prototype.saveCluster = function () {\n  if (this.oldcluster) {\n    this.oldcluster.clear();\n    if (!this.get('animationDuration')) return;\n    var features = this.getSource().getFeatures();\n\n    if (features.length && features[0].get('features')) {\n      this.oldcluster.addFeatures(this.clusters);\n      this.clusters = features.slice(0);\n      this.sourceChanged = true;\n    }\n  }\n};\n/** \r\n * Get the cluster that contains a feature\r\n * @private\r\n*/\n\n\nol_layer_AnimatedCluster.prototype.getClusterForFeature = function (f, cluster) {\n  for (var j = 0, c; c = cluster[j]; j++) {\n    var features = c.get('features');\n\n    if (features && features.length) {\n      for (var k = 0, f2; f2 = features[k]; k++) {\n        if (f === f2) {\n          return c;\n        }\n      }\n    }\n  }\n\n  return false;\n};\n/** \r\n * Stop animation \r\n * @private \r\n */\n\n\nol_layer_AnimatedCluster.prototype.stopAnimation = function () {\n  this.animation.start = false;\n  this.animation.cA = [];\n  this.animation.cB = [];\n};\n/** \r\n * animate the cluster\r\n * @private\r\n */\n\n\nol_layer_AnimatedCluster.prototype.animate = function (e) {\n  var duration = this.get('animationDuration');\n  if (!duration) return;\n  var resolution = e.frameState.viewState.resolution;\n  var i,\n      c0,\n      a = this.animation;\n  var time = e.frameState.time; // Start a new animation, if change resolution and source has changed\n\n  if (a.resolution != resolution && this.sourceChanged) {\n    var extent = e.frameState.extent;\n\n    if (a.resolution < resolution) {\n      extent = ol_extent_buffer(extent, 100 * resolution);\n      a.cA = this.oldcluster.getFeaturesInExtent(extent);\n      a.cB = this.getSource().getFeaturesInExtent(extent);\n      a.revers = false;\n    } else {\n      extent = ol_extent_buffer(extent, 100 * resolution);\n      a.cA = this.getSource().getFeaturesInExtent(extent);\n      a.cB = this.oldcluster.getFeaturesInExtent(extent);\n      a.revers = true;\n    }\n\n    a.clusters = [];\n\n    for (i = 0, c0; c0 = a.cA[i]; i++) {\n      var f = c0.get('features');\n\n      if (f && f.length) {\n        var c = this.getClusterForFeature(f[0], a.cB);\n        if (c) a.clusters.push({\n          f: c0,\n          pt: c.getGeometry().getCoordinates()\n        });\n      }\n    } // Save state\n\n\n    a.resolution = resolution;\n    this.sourceChanged = false; // No cluster or too much to animate\n\n    if (!a.clusters.length || a.clusters.length > 1000) {\n      this.stopAnimation();\n      return;\n    } // Start animation from now\n\n\n    time = a.start = new Date().getTime();\n  } // Run animation\n\n\n  if (a.start) {\n    var vectorContext = e.vectorContext || ol_render_getVectorContext(e);\n    var d = (time - a.start) / duration; // Animation ends\n\n    if (d > 1.0) {\n      this.stopAnimation();\n      d = 1;\n    }\n\n    d = this.get('animationMethod')(d); // Animate\n\n    var style = this.getStyle();\n    var stylefn = typeof style == 'function' ? style : style.length ? function () {\n      return style;\n    } : function () {\n      return [style];\n    }; // Layer opacity\n\n    e.context.save();\n    e.context.globalAlpha = this.getOpacity();\n\n    for (i = 0, c; c = a.clusters[i]; i++) {\n      var pt = c.f.getGeometry().getCoordinates();\n      var dx = pt[0] - c.pt[0];\n      var dy = pt[1] - c.pt[1];\n\n      if (a.revers) {\n        pt[0] = c.pt[0] + d * dx;\n        pt[1] = c.pt[1] + d * dy;\n      } else {\n        pt[0] = pt[0] - d * dx;\n        pt[1] = pt[1] - d * dy;\n      } // Draw feature\n\n\n      var st = stylefn(c.f, resolution, true);\n      if (!st.length) st = [st]; // If one feature: draw the feature\n\n      if (c.f.get(\"features\").length === 1 && !dx && !dy) {\n        f = c.f.get(\"features\")[0];\n      } // else draw a point\n      else {\n          var geo = new ol_geom_Point(pt);\n          f = new ol_Feature(geo);\n        }\n\n      for (var k = 0, s; s = st[k]; k++) {\n        // Multi-line text\n        if (s.getText() && /\\n/.test(s.getText().getText())) {\n          var offsetX = s.getText().getOffsetX();\n          var offsetY = s.getText().getOffsetY();\n          var rot = s.getText().getRotation() || 0;\n          var fontSize = Number((s.getText().getFont() || '10px').match(/\\d+/)) * 1.2;\n          var str = s.getText().getText().split('\\n');\n          var dl,\n              nb = str.length - 1;\n          var s2 = s.clone(); // Draw each lines\n\n          str.forEach(function (t, i) {\n            if (i == 1) {\n              // Allready drawn\n              s2.setImage();\n              s2.setFill();\n              s2.setStroke();\n            }\n\n            switch (s.getText().getTextBaseline()) {\n              case 'alphabetic':\n              case 'ideographic':\n              case 'bottom':\n                {\n                  dl = nb;\n                  break;\n                }\n\n              case 'hanging':\n              case 'top':\n                {\n                  dl = 0;\n                  break;\n                }\n\n              default:\n                {\n                  dl = nb / 2;\n                  break;\n                }\n            }\n\n            s2.getText().setOffsetX(offsetX - Math.sin(rot) * fontSize * (i - dl));\n            s2.getText().setOffsetY(offsetY + Math.cos(rot) * fontSize * (i - dl));\n            s2.getText().setText(t);\n            vectorContext.drawFeature(f, s2);\n          });\n        } else {\n          vectorContext.drawFeature(f, s);\n        }\n        /* OLD VERSION OL < 4.3\r\n        // Retina device\r\n        var ratio = e.frameState.pixelRatio;\r\n          var sc;\r\n        // OL < v4.3 : setImageStyle doesn't check retina\r\n        var imgs = ol_Map.prototype.getFeaturesAtPixel ? false : s.getImage();\r\n        if (imgs)\r\n        {\tsc = imgs.getScale(); \r\n          imgs.setScale(sc*ratio); \r\n        }\r\n        // OL3 > v3.14\r\n        if (vectorContext.setStyle)\r\n        {\t// If one feature: draw the feature\r\n          if (c.f.get(\"features\").length===1 && !dx && !dy) {\r\n            vectorContext.drawFeature(c.f.get(\"features\")[0], s);\r\n          }\r\n          // else draw a point\r\n          else {\r\n            vectorContext.setStyle(s);\r\n            vectorContext.drawGeometry(geo);\r\n          }\r\n        }\r\n        // older version\r\n        else\r\n        {\tvectorContext.setImageStyle(imgs);\r\n          vectorContext.setTextStyle(s.getText());\r\n          vectorContext.drawPointGeometry(geo);\r\n        }\r\n        if (imgs) imgs.setScale(sc);\r\n        */\n\n      }\n    }\n\n    e.context.restore(); // tell ol to continue postcompose animation\n\n    e.frameState.animate = true; // Prevent layer drawing (clip with null rect)\n\n    e.context.save();\n    e.context.beginPath();\n    e.context.rect(0, 0, 0, 0);\n    e.context.clip();\n    this.clip_ = true;\n  }\n\n  return;\n};\n/**  \r\n * remove clipping after the layer is drawn\r\n * @private\r\n */\n\n\nol_layer_AnimatedCluster.prototype.postanimate = function (e) {\n  if (this.clip_) {\n    e.context.restore();\n    this.clip_ = false;\n  }\n};\n\nexport default ol_layer_AnimatedCluster;","map":{"version":3,"sources":["/home/daniel/gitRepos/danji90.github.io/node_modules/ol-ext/layer/AnimatedCluster.js"],"names":["ol_ext_inherits","ol_layer_Vector","ol_source_Vector","ol_Feature","easeOut","ol_easing_easeOut","buffer","ol_extent_buffer","ol_geom_Point","ol_render_getVectorContext","ol_layer_AnimatedCluster","opt_options","options","call","oldcluster","clusters","animation","start","set","animationDuration","animationMethod","getSource","on","saveCluster","bind","animate","postanimate","prototype","clear","get","features","getFeatures","length","addFeatures","slice","sourceChanged","getClusterForFeature","f","cluster","j","c","k","f2","stopAnimation","cA","cB","e","duration","resolution","frameState","viewState","i","c0","a","time","extent","getFeaturesInExtent","revers","push","pt","getGeometry","getCoordinates","Date","getTime","vectorContext","d","style","getStyle","stylefn","context","save","globalAlpha","getOpacity","dx","dy","st","geo","s","getText","test","offsetX","getOffsetX","offsetY","getOffsetY","rot","getRotation","fontSize","Number","getFont","match","str","split","dl","nb","s2","clone","forEach","t","setImage","setFill","setStroke","getTextBaseline","setOffsetX","Math","sin","setOffsetY","cos","setText","drawFeature","restore","beginPath","rect","clip","clip_"],"mappings":"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","sourcesContent":["/*\r\n  Copyright (c) 2015 Jean-Marc VIGLINO,\r\n  released under the CeCILL-B license (http://www.cecill.info/).\r\n\r\n  ol_layer_AnimatedCluster is a vector layer that animate cluster\r\n*/\r\nimport ol_ext_inherits from '../util/ext'\r\nimport ol_layer_Vector from 'ol/layer/Vector'\r\nimport ol_source_Vector from 'ol/source/Vector'\r\nimport ol_Feature from 'ol/Feature'\r\nimport {easeOut as ol_easing_easeOut} from 'ol/easing'\r\nimport {buffer as ol_extent_buffer} from 'ol/extent'\r\nimport ol_geom_Point from 'ol/geom/Point'\r\nimport ol_render_getVectorContext from '../util/getVectorContext';\r\n\r\n/**\r\n *  A vector layer for animated cluster\r\n * @constructor \r\n * @extends {ol.layer.Vector}\r\n * @param {olx.layer.AnimatedClusterOptions=} options extend olx.layer.Options\r\n *  @param {Number} options.animationDuration animation duration in ms, default is 700ms \r\n *  @param {ol.easingFunction} animationMethod easing method to use, default ol.easing.easeOut\r\n */\r\nvar ol_layer_AnimatedCluster = function(opt_options) {\r\n  var options = opt_options || {};\r\n\r\n  ol_layer_Vector.call (this, options);\r\n  \r\n  this.oldcluster = new ol_source_Vector();\r\n  this.clusters = [];\r\n  this.animation={start:false};\r\n  this.set('animationDuration', typeof(options.animationDuration)=='number' ? options.animationDuration : 700);\r\n  this.set('animationMethod', options.animationMethod || ol_easing_easeOut);\r\n\r\n  // Save cluster before change\r\n  this.getSource().on('change', this.saveCluster.bind(this));\r\n  // Animate the cluster\r\n  this.on(['precompose','prerender'], this.animate.bind(this));\r\n  this.on(['postcompose','postrender'], this.postanimate.bind(this));\r\n};\r\nol_ext_inherits(ol_layer_AnimatedCluster, ol_layer_Vector);\r\n\r\n/** save cluster features before change\r\n * @private\r\n */\r\nol_layer_AnimatedCluster.prototype.saveCluster = function() {\r\n  if (this.oldcluster) {\r\n    this.oldcluster.clear();\r\n    if (!this.get('animationDuration')) return;\r\n    var features = this.getSource().getFeatures();\r\n    if (features.length && features[0].get('features')) {\r\n      this.oldcluster.addFeatures (this.clusters);\r\n      this.clusters = features.slice(0);\r\n      this.sourceChanged = true;\r\n    }\r\n  }\r\n};\r\n\r\n/** \r\n * Get the cluster that contains a feature\r\n * @private\r\n*/\r\nol_layer_AnimatedCluster.prototype.getClusterForFeature = function(f, cluster) {\r\n  for (var j=0, c; c=cluster[j]; j++) {\r\n    var features = c.get('features');\r\n    if (features && features.length) {\r\n      for (var k=0, f2; f2=features[k]; k++) {\r\n        if (f===f2) {\r\n          return c;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\n/** \r\n * Stop animation \r\n * @private \r\n */\r\nol_layer_AnimatedCluster.prototype.stopAnimation = function() {\r\n  this.animation.start = false;\r\n  this.animation.cA = [];\r\n  this.animation.cB = [];\r\n};\r\n\r\n/** \r\n * animate the cluster\r\n * @private\r\n */\r\nol_layer_AnimatedCluster.prototype.animate = function(e) {\r\n  var duration = this.get('animationDuration');\r\n  if (!duration) return;\r\n  var resolution = e.frameState.viewState.resolution;\r\n  var i, c0, a = this.animation;\r\n  var time = e.frameState.time;\r\n\r\n  // Start a new animation, if change resolution and source has changed\r\n  if (a.resolution != resolution && this.sourceChanged) {\r\n    var extent = e.frameState.extent;\r\n    if (a.resolution < resolution) {\r\n      extent = ol_extent_buffer(extent, 100*resolution);\r\n      a.cA = this.oldcluster.getFeaturesInExtent(extent);\r\n      a.cB = this.getSource().getFeaturesInExtent(extent);\r\n      a.revers = false;\r\n    } else {\r\n      extent = ol_extent_buffer(extent, 100*resolution);\r\n      a.cA = this.getSource().getFeaturesInExtent(extent);\r\n      a.cB = this.oldcluster.getFeaturesInExtent(extent);\r\n      a.revers = true;\r\n    }\r\n    a.clusters = [];\r\n    for (i=0, c0; c0=a.cA[i]; i++) {\r\n      var f = c0.get('features');\r\n      if (f && f.length) {\r\n        var c = this.getClusterForFeature (f[0], a.cB);\r\n        if (c) a.clusters.push({ f:c0, pt:c.getGeometry().getCoordinates() });\r\n      }\r\n    }\r\n    // Save state\r\n    a.resolution = resolution;\r\n    this.sourceChanged = false;\r\n\r\n    // No cluster or too much to animate\r\n    if (!a.clusters.length || a.clusters.length>1000) {\r\n      this.stopAnimation();\r\n      return;\r\n    }\r\n    // Start animation from now\r\n    time = a.start = (new Date()).getTime();\r\n  }\r\n\r\n  // Run animation\r\n  if (a.start) {\r\n    var vectorContext = e.vectorContext || ol_render_getVectorContext(e);\r\n    var d = (time - a.start) / duration;\r\n    // Animation ends\r\n    if (d > 1.0) {\r\n      this.stopAnimation();\r\n      d = 1;\r\n    }\r\n    d = this.get('animationMethod')(d);\r\n    // Animate\r\n    var style = this.getStyle();\r\n    var stylefn = (typeof(style) == 'function') ? style : style.length ? function(){ return style; } : function(){ return [style]; } ;\r\n    // Layer opacity\r\n    e.context.save();\r\n    e.context.globalAlpha = this.getOpacity();\r\n    for (i=0, c; c=a.clusters[i]; i++) {\r\n      var pt = c.f.getGeometry().getCoordinates();\r\n      var dx = pt[0]-c.pt[0];\r\n      var dy = pt[1]-c.pt[1];\r\n      if (a.revers) {\r\n        pt[0] = c.pt[0] + d * dx;\r\n        pt[1] = c.pt[1] + d * dy;\r\n      } else {\r\n        pt[0] = pt[0] - d * dx;\r\n        pt[1] = pt[1] - d * dy;\r\n      }\r\n      // Draw feature\r\n      var st = stylefn(c.f, resolution, true);\r\n      if (!st.length) st = [st];\r\n      // If one feature: draw the feature\r\n      if (c.f.get(\"features\").length===1 && !dx && !dy) {\r\n        f = c.f.get(\"features\")[0];\r\n      }\r\n      // else draw a point\r\n      else {\r\n        var geo = new ol_geom_Point(pt);\r\n        f = new ol_Feature(geo);\r\n      }\r\n      for (var k=0, s; s=st[k]; k++) {\r\n        // Multi-line text\r\n        if (s.getText() && /\\n/.test(s.getText().getText())) {\r\n          var offsetX = s.getText().getOffsetX();\r\n          var offsetY = s.getText().getOffsetY();\r\n          var rot = s.getText().getRotation() || 0;\r\n          var fontSize = Number((s.getText().getFont() || '10px').match(/\\d+/)) * 1.2;\r\n          var str = s.getText().getText().split('\\n')\r\n          var dl, nb = str.length-1;\r\n          var s2 = s.clone();\r\n          // Draw each lines\r\n          str.forEach(function(t, i) {\r\n            if (i==1) {\r\n              // Allready drawn\r\n              s2.setImage();\r\n              s2.setFill();\r\n              s2.setStroke();\r\n            }\r\n            switch (s.getText().getTextBaseline()) {\r\n              case 'alphabetic':\r\n              case 'ideographic':\r\n              case 'bottom': {\r\n                dl = nb;\r\n                break;\r\n              }\r\n              case 'hanging':\r\n              case 'top': {\r\n                dl = 0;\r\n                break;\r\n              }\r\n              default : {\r\n                dl = nb/2;\r\n                break;\r\n              }\r\n            }\r\n            s2.getText().setOffsetX(offsetX - Math.sin(rot)*fontSize*(i - dl));\r\n            s2.getText().setOffsetY(offsetY + Math.cos(rot)*fontSize*(i - dl));\r\n            s2.getText().setText(t);\r\n            vectorContext.drawFeature(f, s2);\r\n          });\r\n        } else {\r\n          vectorContext.drawFeature(f, s);\r\n        }\r\n        /* OLD VERSION OL < 4.3\r\n        // Retina device\r\n        var ratio = e.frameState.pixelRatio;\r\n\r\n        var sc;\r\n        // OL < v4.3 : setImageStyle doesn't check retina\r\n        var imgs = ol_Map.prototype.getFeaturesAtPixel ? false : s.getImage();\r\n        if (imgs)\r\n        {\tsc = imgs.getScale(); \r\n          imgs.setScale(sc*ratio); \r\n        }\r\n        // OL3 > v3.14\r\n        if (vectorContext.setStyle)\r\n        {\t// If one feature: draw the feature\r\n          if (c.f.get(\"features\").length===1 && !dx && !dy) {\r\n            vectorContext.drawFeature(c.f.get(\"features\")[0], s);\r\n          }\r\n          // else draw a point\r\n          else {\r\n            vectorContext.setStyle(s);\r\n            vectorContext.drawGeometry(geo);\r\n          }\r\n        }\r\n        // older version\r\n        else\r\n        {\tvectorContext.setImageStyle(imgs);\r\n          vectorContext.setTextStyle(s.getText());\r\n          vectorContext.drawPointGeometry(geo);\r\n        }\r\n        if (imgs) imgs.setScale(sc);\r\n        */\r\n      }\r\n    }\r\n    e.context.restore();\r\n    // tell ol to continue postcompose animation\r\n    e.frameState.animate = true;\r\n\r\n    // Prevent layer drawing (clip with null rect)\r\n    e.context.save();\r\n    e.context.beginPath();\r\n    e.context.rect(0,0,0,0);\r\n    e.context.clip();\r\n    this.clip_ = true;\r\n  }\r\n\r\n  return;\r\n};\r\n\r\n/**  \r\n * remove clipping after the layer is drawn\r\n * @private\r\n */\r\nol_layer_AnimatedCluster.prototype.postanimate = function(e) {\r\n  if (this.clip_) {\r\n    e.context.restore();\r\n    this.clip_ = false;\r\n  }\r\n};\r\n\r\nexport default ol_layer_AnimatedCluster\r\n"]},"metadata":{},"sourceType":"module"}