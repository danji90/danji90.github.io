{"ast":null,"code":"import _toConsumableArray from \"/home/daniel/gitRepos/danji90.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/home/daniel/gitRepos/danji90.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/daniel/gitRepos/danji90.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\n * Class use to facilitate connection to a WebSocket\n * @private\n */\nvar WebSocketConnector = /*#__PURE__*/function () {\n  function WebSocketConnector(url) {\n    var _this = this;\n\n    _classCallCheck(this, WebSocketConnector);\n\n    /**\n     * Array of subscriptions.\n     * @type {Array<subscription>}\n     */\n    this.subscriptions = [];\n    this.connect(url); // keep websocket alive\n\n    setInterval(function () {\n      _this.send('PING');\n    }, 10000);\n  }\n  /**\n   * Get the websocket request string.\n   * @param {string} method Request mehtod {GET, SUB}.\n   * @param {Object} params Request parameters.\n   * @param {string} params.channel Channel name\n   * @param {string} [params.args] Request arguments\n   * @param {Number} [params.id] Request identifier\n   * @returns {string} request string\n   * @private\n   */\n\n\n  _createClass(WebSocketConnector, [{\n    key: \"connect\",\n    value:\n    /**\n     * (Re)connect the websocket.\n     * @param {string} url url to connect to\n     * @private\n     */\n    function connect(url) {\n      var _this2 = this;\n\n      if (this.websocket && this.websocket.readyState !== this.websocket.CLOSED) {\n        this.websocket.close();\n      }\n      /** @ignore */\n\n\n      this.websocket = new WebSocket(url);\n\n      if (this.currentProj) {\n        this.setProjection(this.currentProj);\n      }\n\n      if (this.currentBbox) {\n        this.setBbox(this.currentBbox);\n      }\n\n      _toConsumableArray(this.subscriptions).forEach(function (s) {\n        _this2.subscribe(s.params, s.cb, s.errorCb, true);\n      }); // reconnect on close\n\n\n      this.websocket.onclose = function () {\n        window.clearTimeout(_this2.reconnectTimeout);\n        /** @ignore */\n\n        _this2.reconnectTimeout = window.setTimeout(function () {\n          return _this2.connect(url);\n        }, 100);\n      };\n    }\n    /**\n     * Sends a get request to the websocket.\n     * @param {Object} params Parameters for the websocket get request\n     * @param {function} cb callback on listen\n     * @param {function} errorCb Callback on error\n     * @private\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(params, cb, errorCb) {\n      var reqStr = WebSocketConnector.getRequestString('GET', params);\n      this.send(reqStr);\n      this.listen(params, cb, errorCb);\n    }\n    /**\n     * Sends a message to the websocket.\n     * @param {message} message Message to send.\n     * @private\n     */\n\n  }, {\n    key: \"send\",\n    value: function send(message) {\n      var _this3 = this;\n\n      var send = function send() {\n        _this3.websocket.send(message);\n      };\n\n      if (this.websocket.readyState === WebSocket.CONNECTING) {\n        this.websocket.addEventListener('open', send);\n      } else {\n        send();\n      }\n    }\n    /**\n     * Set the projection for websocket responses.\n     * @param {string} value projection value to be set\n     * @private\n     */\n\n  }, {\n    key: \"setProjection\",\n    value: function setProjection(value) {\n      /**\n       * The projection for websocket responses\n       * @type {string}\n       */\n      this.currentProj = value;\n      this.send(\"PROJECTION \".concat(value));\n    }\n    /**\n     * Set the BBOX for websocket responses.\n     *  @param {Array<Array<number>>} coordinates array of coordinates\n     * @private\n     */\n\n  }, {\n    key: \"setBbox\",\n    value: function setBbox(coordinates) {\n      var _this4 = this;\n\n      /**\n       * The BBOX for websocket responses\n       * @type {Array<Array<number>>}\n       */\n      this.currentBbox = coordinates;\n      this.send(\"BBOX \".concat(coordinates.join(' ')));\n      this.subscriptions.forEach(function (s) {\n        _this4.get(s.params, s.cb, s.errorCb);\n      });\n    }\n    /**\n     * Listen to websocket responses.\n     * @private\n     * @param {Object} params Parameters for the websocket get request\n     * @param {function} cb callback on listen\n     * @param {function} errorCb Callback on error\n     * @returns {{onMessage: function, errorCb: function}} Object with onMessage and error callbacks\n     */\n\n  }, {\n    key: \"listen\",\n    value: function listen(params, cb, errorCb) {\n      var onMessage = function onMessage(e) {\n        var data = JSON.parse(e.data);\n        var source = params.channel;\n        source += params.args ? \" \".concat(params.args) : '';\n\n        if (data.source === source && (!params.id || params.id === data.client_reference)) {\n          cb(data);\n        }\n      };\n\n      this.websocket.addEventListener('message', onMessage);\n\n      if (errorCb) {\n        this.websocket.addEventListener('error', errorCb);\n        this.websocket.addEventListener('close', errorCb);\n      }\n\n      return {\n        onMessage: onMessage,\n        onErrorCb: errorCb\n      };\n    }\n    /**\n     * Subscribe to a given channel.\n     * @private\n     * @param {Object} params Parameters for the websocket get request\n     * @param {function} cb callback on listen\n     * @param {function} errorCb Callback on error\n     * @param {boolean} quiet if subscribe should be quiet\n     */\n\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(params, cb, errorCb, quiet) {\n      var _this$listen = this.listen(params, cb, errorCb),\n          onMessageCb = _this$listen.onMessageCb,\n          onErrorCb = _this$listen.onErrorCb;\n\n      var reqStr = WebSocketConnector.getRequestString('', params);\n\n      if (!quiet) {\n        this.subscriptions.push({\n          params: params,\n          cb: cb,\n          errorCb: errorCb,\n          onMessageCb: onMessageCb,\n          onErrorCb: onErrorCb\n        });\n      }\n\n      this.send(\"GET \".concat(reqStr));\n      this.send(\"SUB \".concat(reqStr));\n    }\n    /**\n     * Unsubscribe from a channel.\n     * @param {string} source source to unsubscribe from\n     * @private\n     */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(source) {\n      var _this5 = this;\n\n      this.subscriptions.filter(function (s) {\n        return s.params.channel === source;\n      }).forEach(function (_ref) {\n        var onMessageCb = _ref.onMessageCb,\n            onErrorCb = _ref.onErrorCb;\n\n        _this5.websocket.removeEventListener('message', onMessageCb);\n\n        if (onErrorCb) {\n          _this5.websocket.removeEventListener('error', onErrorCb);\n\n          _this5.websocket.removeEventListener('close', onErrorCb);\n        }\n      });\n      this.subscriptions = this.subscriptions.filter(function (s) {\n        return s.params.channel !== source;\n      });\n\n      if (source) {\n        this.send(\"DEL \".concat(source));\n      }\n    }\n  }], [{\n    key: \"getRequestString\",\n    value: function getRequestString(method, params) {\n      var reqStr = \"\".concat(method, \" \").concat(params.channel);\n      reqStr += params.args ? \" \".concat(params.args) : '';\n      reqStr += params.id ? \" \".concat(params.id) : '';\n      return reqStr.trim();\n    }\n  }]);\n\n  return WebSocketConnector;\n}();\n\nexport default WebSocketConnector;","map":{"version":3,"sources":["/home/daniel/gitRepos/danji90.github.io/node_modules/mobility-toolbox-js/api/tralis/WebSocketConnector.js"],"names":["WebSocketConnector","url","subscriptions","connect","setInterval","send","websocket","readyState","CLOSED","close","WebSocket","currentProj","setProjection","currentBbox","setBbox","forEach","s","subscribe","params","cb","errorCb","onclose","window","clearTimeout","reconnectTimeout","setTimeout","reqStr","getRequestString","listen","message","CONNECTING","addEventListener","value","coordinates","join","get","onMessage","e","data","JSON","parse","source","channel","args","id","client_reference","onErrorCb","quiet","onMessageCb","push","filter","removeEventListener","method","trim"],"mappings":";;;;AAAA;AACA;AACA;AACA;IACMA,kB;AACJ,8BAAYC,GAAZ,EAAiB;AAAA;;AAAA;;AACf;AACJ;AACA;AACA;AACI,SAAKC,aAAL,GAAqB,EAArB;AACA,SAAKC,OAAL,CAAaF,GAAb,EANe,CAQf;;AACAG,IAAAA,WAAW,CAAC,YAAM;AAChB,MAAA,KAAI,CAACC,IAAL,CAAU,MAAV;AACD,KAFU,EAER,KAFQ,CAAX;AAGD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAQE;AACF;AACA;AACA;AACA;AACE,qBAAQJ,GAAR,EAAa;AAAA;;AACX,UAAI,KAAKK,SAAL,IAAkB,KAAKA,SAAL,CAAeC,UAAf,KAA8B,KAAKD,SAAL,CAAeE,MAAnE,EAA2E;AACzE,aAAKF,SAAL,CAAeG,KAAf;AACD;AAED;;;AACA,WAAKH,SAAL,GAAiB,IAAII,SAAJ,CAAcT,GAAd,CAAjB;;AAEA,UAAI,KAAKU,WAAT,EAAsB;AACpB,aAAKC,aAAL,CAAmB,KAAKD,WAAxB;AACD;;AAED,UAAI,KAAKE,WAAT,EAAsB;AACpB,aAAKC,OAAL,CAAa,KAAKD,WAAlB;AACD;;AAED,yBAAI,KAAKX,aAAT,EAAwBa,OAAxB,CAAgC,UAACC,CAAD,EAAO;AACrC,QAAA,MAAI,CAACC,SAAL,CAAeD,CAAC,CAACE,MAAjB,EAAyBF,CAAC,CAACG,EAA3B,EAA+BH,CAAC,CAACI,OAAjC,EAA0C,IAA1C;AACD,OAFD,EAhBW,CAoBX;;;AACA,WAAKd,SAAL,CAAee,OAAf,GAAyB,YAAM;AAC7BC,QAAAA,MAAM,CAACC,YAAP,CAAoB,MAAI,CAACC,gBAAzB;AACA;;AACA,QAAA,MAAI,CAACA,gBAAL,GAAwBF,MAAM,CAACG,UAAP,CAAkB;AAAA,iBAAM,MAAI,CAACtB,OAAL,CAAaF,GAAb,CAAN;AAAA,SAAlB,EAA2C,GAA3C,CAAxB;AACD,OAJD;AAKD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,aAAIiB,MAAJ,EAAYC,EAAZ,EAAgBC,OAAhB,EAAyB;AACvB,UAAMM,MAAM,GAAG1B,kBAAkB,CAAC2B,gBAAnB,CAAoC,KAApC,EAA2CT,MAA3C,CAAf;AACA,WAAKb,IAAL,CAAUqB,MAAV;AACA,WAAKE,MAAL,CAAYV,MAAZ,EAAoBC,EAApB,EAAwBC,OAAxB;AACD;AAED;AACF;AACA;AACA;AACA;;;;WACE,cAAKS,OAAL,EAAc;AAAA;;AACZ,UAAMxB,IAAI,GAAG,SAAPA,IAAO,GAAM;AACjB,QAAA,MAAI,CAACC,SAAL,CAAeD,IAAf,CAAoBwB,OAApB;AACD,OAFD;;AAIA,UAAI,KAAKvB,SAAL,CAAeC,UAAf,KAA8BG,SAAS,CAACoB,UAA5C,EAAwD;AACtD,aAAKxB,SAAL,CAAeyB,gBAAf,CAAgC,MAAhC,EAAwC1B,IAAxC;AACD,OAFD,MAEO;AACLA,QAAAA,IAAI;AACL;AACF;AAED;AACF;AACA;AACA;AACA;;;;WACE,uBAAc2B,KAAd,EAAqB;AACnB;AACJ;AACA;AACA;AACI,WAAKrB,WAAL,GAAmBqB,KAAnB;AACA,WAAK3B,IAAL,sBAAwB2B,KAAxB;AACD;AAED;AACF;AACA;AACA;AACA;;;;WACE,iBAAQC,WAAR,EAAqB;AAAA;;AACnB;AACJ;AACA;AACA;AACI,WAAKpB,WAAL,GAAmBoB,WAAnB;AACA,WAAK5B,IAAL,gBAAkB4B,WAAW,CAACC,IAAZ,CAAiB,GAAjB,CAAlB;AACA,WAAKhC,aAAL,CAAmBa,OAAnB,CAA2B,UAACC,CAAD,EAAO;AAChC,QAAA,MAAI,CAACmB,GAAL,CAASnB,CAAC,CAACE,MAAX,EAAmBF,CAAC,CAACG,EAArB,EAAyBH,CAAC,CAACI,OAA3B;AACD,OAFD;AAGD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,gBAAOF,MAAP,EAAeC,EAAf,EAAmBC,OAAnB,EAA4B;AAC1B,UAAMgB,SAAS,GAAG,SAAZA,SAAY,CAACC,CAAD,EAAO;AACvB,YAAMC,IAAI,GAAGC,IAAI,CAACC,KAAL,CAAWH,CAAC,CAACC,IAAb,CAAb;AACA,YAAIG,MAAM,GAAGvB,MAAM,CAACwB,OAApB;AACAD,QAAAA,MAAM,IAAIvB,MAAM,CAACyB,IAAP,cAAkBzB,MAAM,CAACyB,IAAzB,IAAkC,EAA5C;;AAEA,YACEL,IAAI,CAACG,MAAL,KAAgBA,MAAhB,KACC,CAACvB,MAAM,CAAC0B,EAAR,IAAc1B,MAAM,CAAC0B,EAAP,KAAcN,IAAI,CAACO,gBADlC,CADF,EAGE;AACA1B,UAAAA,EAAE,CAACmB,IAAD,CAAF;AACD;AACF,OAXD;;AAaA,WAAKhC,SAAL,CAAeyB,gBAAf,CAAgC,SAAhC,EAA2CK,SAA3C;;AAEA,UAAIhB,OAAJ,EAAa;AACX,aAAKd,SAAL,CAAeyB,gBAAf,CAAgC,OAAhC,EAAyCX,OAAzC;AACA,aAAKd,SAAL,CAAeyB,gBAAf,CAAgC,OAAhC,EAAyCX,OAAzC;AACD;;AAED,aAAO;AAAEgB,QAAAA,SAAS,EAATA,SAAF;AAAaU,QAAAA,SAAS,EAAE1B;AAAxB,OAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,mBAAUF,MAAV,EAAkBC,EAAlB,EAAsBC,OAAtB,EAA+B2B,KAA/B,EAAsC;AACpC,yBAAmC,KAAKnB,MAAL,CAAYV,MAAZ,EAAoBC,EAApB,EAAwBC,OAAxB,CAAnC;AAAA,UAAQ4B,WAAR,gBAAQA,WAAR;AAAA,UAAqBF,SAArB,gBAAqBA,SAArB;;AACA,UAAMpB,MAAM,GAAG1B,kBAAkB,CAAC2B,gBAAnB,CAAoC,EAApC,EAAwCT,MAAxC,CAAf;;AAEA,UAAI,CAAC6B,KAAL,EAAY;AACV,aAAK7C,aAAL,CAAmB+C,IAAnB,CAAwB;AAAE/B,UAAAA,MAAM,EAANA,MAAF;AAAUC,UAAAA,EAAE,EAAFA,EAAV;AAAcC,UAAAA,OAAO,EAAPA,OAAd;AAAuB4B,UAAAA,WAAW,EAAXA,WAAvB;AAAoCF,UAAAA,SAAS,EAATA;AAApC,SAAxB;AACD;;AAED,WAAKzC,IAAL,eAAiBqB,MAAjB;AACA,WAAKrB,IAAL,eAAiBqB,MAAjB;AACD;AAED;AACF;AACA;AACA;AACA;;;;WACE,qBAAYe,MAAZ,EAAoB;AAAA;;AAClB,WAAKvC,aAAL,CACGgD,MADH,CACU,UAAClC,CAAD;AAAA,eAAOA,CAAC,CAACE,MAAF,CAASwB,OAAT,KAAqBD,MAA5B;AAAA,OADV,EAEG1B,OAFH,CAEW,gBAAgC;AAAA,YAA7BiC,WAA6B,QAA7BA,WAA6B;AAAA,YAAhBF,SAAgB,QAAhBA,SAAgB;;AACvC,QAAA,MAAI,CAACxC,SAAL,CAAe6C,mBAAf,CAAmC,SAAnC,EAA8CH,WAA9C;;AACA,YAAIF,SAAJ,EAAe;AACb,UAAA,MAAI,CAACxC,SAAL,CAAe6C,mBAAf,CAAmC,OAAnC,EAA4CL,SAA5C;;AACA,UAAA,MAAI,CAACxC,SAAL,CAAe6C,mBAAf,CAAmC,OAAnC,EAA4CL,SAA5C;AACD;AACF,OARH;AAUA,WAAK5C,aAAL,GAAqB,KAAKA,aAAL,CAAmBgD,MAAnB,CACnB,UAAClC,CAAD;AAAA,eAAOA,CAAC,CAACE,MAAF,CAASwB,OAAT,KAAqBD,MAA5B;AAAA,OADmB,CAArB;;AAIA,UAAIA,MAAJ,EAAY;AACV,aAAKpC,IAAL,eAAiBoC,MAAjB;AACD;AACF;;;WAhLD,0BAAwBW,MAAxB,EAAgClC,MAAhC,EAAwC;AACtC,UAAIQ,MAAM,aAAM0B,MAAN,cAAgBlC,MAAM,CAACwB,OAAvB,CAAV;AACAhB,MAAAA,MAAM,IAAIR,MAAM,CAACyB,IAAP,cAAkBzB,MAAM,CAACyB,IAAzB,IAAkC,EAA5C;AACAjB,MAAAA,MAAM,IAAIR,MAAM,CAAC0B,EAAP,cAAgB1B,MAAM,CAAC0B,EAAvB,IAA8B,EAAxC;AACA,aAAOlB,MAAM,CAAC2B,IAAP,EAAP;AACD;;;;;;AA8KH,eAAerD,kBAAf","sourcesContent":["/**\n * Class use to facilitate connection to a WebSocket\n * @private\n */\nclass WebSocketConnector {\n  constructor(url) {\n    /**\n     * Array of subscriptions.\n     * @type {Array<subscription>}\n     */\n    this.subscriptions = [];\n    this.connect(url);\n\n    // keep websocket alive\n    setInterval(() => {\n      this.send('PING');\n    }, 10000);\n  }\n\n  /**\n   * Get the websocket request string.\n   * @param {string} method Request mehtod {GET, SUB}.\n   * @param {Object} params Request parameters.\n   * @param {string} params.channel Channel name\n   * @param {string} [params.args] Request arguments\n   * @param {Number} [params.id] Request identifier\n   * @returns {string} request string\n   * @private\n   */\n  static getRequestString(method, params) {\n    let reqStr = `${method} ${params.channel}`;\n    reqStr += params.args ? ` ${params.args}` : '';\n    reqStr += params.id ? ` ${params.id}` : '';\n    return reqStr.trim();\n  }\n\n  /**\n   * (Re)connect the websocket.\n   * @param {string} url url to connect to\n   * @private\n   */\n  connect(url) {\n    if (this.websocket && this.websocket.readyState !== this.websocket.CLOSED) {\n      this.websocket.close();\n    }\n\n    /** @ignore */\n    this.websocket = new WebSocket(url);\n\n    if (this.currentProj) {\n      this.setProjection(this.currentProj);\n    }\n\n    if (this.currentBbox) {\n      this.setBbox(this.currentBbox);\n    }\n\n    [...this.subscriptions].forEach((s) => {\n      this.subscribe(s.params, s.cb, s.errorCb, true);\n    });\n\n    // reconnect on close\n    this.websocket.onclose = () => {\n      window.clearTimeout(this.reconnectTimeout);\n      /** @ignore */\n      this.reconnectTimeout = window.setTimeout(() => this.connect(url), 100);\n    };\n  }\n\n  /**\n   * Sends a get request to the websocket.\n   * @param {Object} params Parameters for the websocket get request\n   * @param {function} cb callback on listen\n   * @param {function} errorCb Callback on error\n   * @private\n   */\n  get(params, cb, errorCb) {\n    const reqStr = WebSocketConnector.getRequestString('GET', params);\n    this.send(reqStr);\n    this.listen(params, cb, errorCb);\n  }\n\n  /**\n   * Sends a message to the websocket.\n   * @param {message} message Message to send.\n   * @private\n   */\n  send(message) {\n    const send = () => {\n      this.websocket.send(message);\n    };\n\n    if (this.websocket.readyState === WebSocket.CONNECTING) {\n      this.websocket.addEventListener('open', send);\n    } else {\n      send();\n    }\n  }\n\n  /**\n   * Set the projection for websocket responses.\n   * @param {string} value projection value to be set\n   * @private\n   */\n  setProjection(value) {\n    /**\n     * The projection for websocket responses\n     * @type {string}\n     */\n    this.currentProj = value;\n    this.send(`PROJECTION ${value}`);\n  }\n\n  /**\n   * Set the BBOX for websocket responses.\n   *  @param {Array<Array<number>>} coordinates array of coordinates\n   * @private\n   */\n  setBbox(coordinates) {\n    /**\n     * The BBOX for websocket responses\n     * @type {Array<Array<number>>}\n     */\n    this.currentBbox = coordinates;\n    this.send(`BBOX ${coordinates.join(' ')}`);\n    this.subscriptions.forEach((s) => {\n      this.get(s.params, s.cb, s.errorCb);\n    });\n  }\n\n  /**\n   * Listen to websocket responses.\n   * @private\n   * @param {Object} params Parameters for the websocket get request\n   * @param {function} cb callback on listen\n   * @param {function} errorCb Callback on error\n   * @returns {{onMessage: function, errorCb: function}} Object with onMessage and error callbacks\n   */\n  listen(params, cb, errorCb) {\n    const onMessage = (e) => {\n      const data = JSON.parse(e.data);\n      let source = params.channel;\n      source += params.args ? ` ${params.args}` : '';\n\n      if (\n        data.source === source &&\n        (!params.id || params.id === data.client_reference)\n      ) {\n        cb(data);\n      }\n    };\n\n    this.websocket.addEventListener('message', onMessage);\n\n    if (errorCb) {\n      this.websocket.addEventListener('error', errorCb);\n      this.websocket.addEventListener('close', errorCb);\n    }\n\n    return { onMessage, onErrorCb: errorCb };\n  }\n\n  /**\n   * Subscribe to a given channel.\n   * @private\n   * @param {Object} params Parameters for the websocket get request\n   * @param {function} cb callback on listen\n   * @param {function} errorCb Callback on error\n   * @param {boolean} quiet if subscribe should be quiet\n   */\n  subscribe(params, cb, errorCb, quiet) {\n    const { onMessageCb, onErrorCb } = this.listen(params, cb, errorCb);\n    const reqStr = WebSocketConnector.getRequestString('', params);\n\n    if (!quiet) {\n      this.subscriptions.push({ params, cb, errorCb, onMessageCb, onErrorCb });\n    }\n\n    this.send(`GET ${reqStr}`);\n    this.send(`SUB ${reqStr}`);\n  }\n\n  /**\n   * Unsubscribe from a channel.\n   * @param {string} source source to unsubscribe from\n   * @private\n   */\n  unsubscribe(source) {\n    this.subscriptions\n      .filter((s) => s.params.channel === source)\n      .forEach(({ onMessageCb, onErrorCb }) => {\n        this.websocket.removeEventListener('message', onMessageCb);\n        if (onErrorCb) {\n          this.websocket.removeEventListener('error', onErrorCb);\n          this.websocket.removeEventListener('close', onErrorCb);\n        }\n      });\n\n    this.subscriptions = this.subscriptions.filter(\n      (s) => s.params.channel !== source,\n    );\n\n    if (source) {\n      this.send(`DEL ${source}`);\n    }\n  }\n}\n\nexport default WebSocketConnector;\n"]},"metadata":{},"sourceType":"module"}