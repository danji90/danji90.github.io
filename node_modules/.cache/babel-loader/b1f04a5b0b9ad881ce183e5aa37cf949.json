{"ast":null,"code":"import _objectSpread from \"/home/daniel/gitRepos/danji90.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _classCallCheck from \"/home/daniel/gitRepos/danji90.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/daniel/gitRepos/danji90.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/home/daniel/gitRepos/danji90.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _get from \"/home/daniel/gitRepos/danji90.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/home/daniel/gitRepos/danji90.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/daniel/gitRepos/danji90.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/daniel/gitRepos/danji90.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/* eslint-disable no-param-reassign */\nimport Layer from './Layer';\n/**\n * Apply visibility to style layers that fits the filter function.\n * @private\n */\n\nvar applyLayoutVisibility = function applyLayoutVisibility(mbMap, visible, filterFunc) {\n  if (!mbMap) {\n    return;\n  }\n\n  var style = mbMap.getStyle();\n\n  if (!style) {\n    return;\n  }\n\n  if (filterFunc) {\n    var visibilityValue = visible ? 'visible' : 'none';\n\n    for (var i = 0; i < style.layers.length; i += 1) {\n      var styleLayer = style.layers[i];\n\n      if (filterFunc(styleLayer)) {\n        if (mbMap.getLayer(styleLayer.id)) {\n          mbMap.setLayoutProperty(styleLayer.id, 'visibility', visibilityValue);\n        }\n      }\n    }\n  }\n};\n/**\n * Layer for visualizing a specific set of layer from a MapboxLayer.\n *\n * @example\n * import { MapboxLayer, MapboxStyleLayer } from 'mobility-toolbox-js/ol';\n *\n * const mapboxLayer = new MapboxLayer({\n *   url: 'https://maps.geops.io/styles/travic_v2/style.json?key=[yourApiKey]',\n * });\n *\n * const layer = new MapboxStyleLayer({\n *   mapboxLayer: mapboxLayer,\n *   styleLayersFilter: () => {},\n * });\n *\n * @extends {Layer}\n */\n\n\nvar MapboxStyleLayer = /*#__PURE__*/function (_Layer) {\n  _inherits(MapboxStyleLayer, _Layer);\n\n  var _super = _createSuper(MapboxStyleLayer);\n\n  /**\n   * Constructor.\n   *\n   * @param {Object} options\n   * @param {MapboxLayer} [options.mapboxLayer] The MapboxLayer to use.\n   * @param {Function} [options.styleLayersFilter] Filter function to decide which style layer to display.\n   */\n  function MapboxStyleLayer() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, MapboxStyleLayer);\n\n    _this = _super.call(this, options);\n    /**\n     * MapboxLayer provided for the style Layer.\n     * @type {MapboxLayer}\n     * @private\n     */\n\n    _this.mapboxLayer = options.mapboxLayer;\n    /**\n     * Function to filter features to be displayed.\n     * @type {function}\n     * @private\n     */\n\n    _this.styleLayersFilter = options.styleLayersFilter;\n    /**\n     * Mapbox style layer id where to add the style layers.\n     * See [mapbox.map.addLayer](https://docs.mapbox.com/mapbox-gl-js/api/map/#map#addlayer) documentation.\n     * @type {String}\n     * @private\n     */\n\n    _this.beforeId = options.beforeId;\n    /**\n     * Function to filter features for getFeatureInfoAtCoordinate method.\n     * @type {function}\n     * @private\n     */\n\n    _this.featureInfoFilter = options.featureInfoFilter || function (obj) {\n      return obj;\n    };\n    /**\n     * Function to query the rendered features.\n     * @type {function}\n     * @private\n     */\n\n\n    _this.queryRenderedLayersFilter = options.queryRenderedLayersFilter;\n    /**\n     * Array of features to highlight.\n     * @type {Array<ol/Feature~Feature>}\n     * @private\n     */\n\n    _this.highlightedFeatures = [];\n    /**\n     * Array of selected features.\n     * @type {Array<ol/Feature~Feature>}\n     * @private\n     */\n\n    _this.selectedFeatures = [];\n    /**\n     * Array of mapbox style layers to add.\n     * @type {Array<mapboxgl.styleLayer>}\n     * @private\n     */\n\n    _this.styleLayers = (options.styleLayer ? [options.styleLayer] : options.styleLayers) || [];\n    /**\n     * @private\n     */\n\n    _this.addStyleLayers = _this.addStyleLayers.bind(_assertThisInitialized(_this));\n    /**\n     * @private\n     */\n\n    _this.onLoad = _this.onLoad.bind(_assertThisInitialized(_this));\n\n    if (options.filters) {\n      /** @private */\n      _this.addDynamicFilters = function () {\n        _this.setFilter(typeof options.filters === 'function' ? options.filters(_assertThisInitialized(_this)) : options.filters);\n      };\n    }\n\n    if (!_this.styleLayersFilter && _this.styleLayers) {\n      var ids = _this.styleLayers.map(function (s) {\n        return s.id;\n      });\n\n      _this.styleLayersFilter = function (styleLayer) {\n        return ids.includes(styleLayer.id);\n      };\n    }\n\n    return _this;\n  }\n  /**\n   * Initialize the layer.\n   * @param {mapboxgl.Map} map the mapbox map.\n   * @override\n   */\n\n\n  _createClass(MapboxStyleLayer, [{\n    key: \"init\",\n    value: function init(map) {\n      var _this2 = this;\n\n      if (!this.mapboxLayer.map) {\n        this.mapboxLayer.init(map);\n        /**\n         * An OpenLayers Layer.\n         * @type {ol/layer/Layer~Layer}\n         * @private\n         */\n\n        this.olLayer = this.mapboxLayer.olLayer;\n      }\n\n      _get(_getPrototypeOf(MapboxStyleLayer.prototype), \"init\", this).call(this, map);\n\n      if (!this.map) {\n        return;\n      } // Apply the initial visibiltity.\n\n\n      var mbMap = this.mapboxLayer.mbMap;\n\n      if (!mbMap) {\n        // If the mbMap is not yet created because the  map has no target yet, we\n        // relaunch the initialisation when it's the case.\n        this.olListenersKeys.push(this.map.on('change:target', function () {\n          _this2.init(map);\n        }));\n        return;\n      } // mbMap.loaded() and mbMap.isStyleLoaded() are reliable only on the first call of init.\n      // On the next call (when a topic change for example), these functions returns false because\n      // the style is being modified.\n      // That's why we rely on a property instead for the next calls.\n\n\n      if (this.mapboxLayer.loaded || mbMap.isStyleLoaded() || mbMap.loaded()) {\n        this.onLoad();\n      } else {\n        mbMap.once('load', this.onLoad);\n      } // Apply the visibiltity when layer's visibility change.\n\n\n      this.olListenersKeys.push(this.on('change:visible', function (_ref) {\n        var layer = _ref.target;\n        // Once the map is loaded we can apply vsiiblity without waiting\n        // the style. Mapbox take care of the application of style changes.\n        applyLayoutVisibility(mbMap, layer.visible, _this2.styleLayersFilter);\n      }));\n      this.olListenersKeys.push(this.mapboxLayer.on('load', function () {\n        _this2.onLoad();\n      })); // Listen to click events\n\n      this.olListenersKeys.push(this.map.on('singleclick', function (e) {\n        if (!_this2.clickCallbacks.length) {\n          return;\n        }\n\n        _this2.getFeatureInfoAtCoordinate(e.coordinate).then(function (d) {\n          return _this2.callClickCallbacks(d.features, d.layer, d.coordinate);\n        }).catch(function () {\n          return _this2.callClickCallbacks([], _this2, e.coordinate);\n        });\n      }));\n    }\n    /**\n     * Call click callbacks with given parameters.\n     * This is done in a separate function for being able to modify the response.\n     * @param {Array<ol/Feature~Feature>} features\n     * @param {ol/layer/Layer~Layer} layer\n     * @param {ol/coordinate~Coordinate} coordinate\n     * @private\n     */\n\n  }, {\n    key: \"callClickCallbacks\",\n    value: function callClickCallbacks(features, layer, coordinate) {\n      this.clickCallbacks.forEach(function (c) {\n        return c(features, layer, coordinate);\n      });\n    }\n    /**\n     * Terminate the layer.\n     * @param {mapboxgl.Map} map the mapbox map.\n     * @override\n     */\n\n  }, {\n    key: \"terminate\",\n    value: function terminate(map) {\n      var mbMap = this.mapboxLayer.mbMap;\n\n      if (mbMap) {\n        mbMap.off('load', this.onLoad);\n        this.removeStyleLayers();\n      }\n\n      _get(_getPrototypeOf(MapboxStyleLayer.prototype), \"terminate\", this).call(this, map);\n    }\n    /** @ignore */\n\n  }, {\n    key: \"addStyleLayers\",\n    value: function addStyleLayers() {\n      var _this3 = this;\n\n      var mbMap = this.mapboxLayer.mbMap;\n\n      if (!mbMap) {\n        return;\n      }\n\n      this.styleLayers.forEach(function (styleLayer) {\n        var id = styleLayer.id,\n            source = styleLayer.source;\n\n        if (mbMap.getSource(source) && !mbMap.getLayer(id)) {\n          mbMap.addLayer(styleLayer, _this3.beforeId);\n        }\n      });\n      applyLayoutVisibility(mbMap, this.visible, this.styleLayersFilter);\n    }\n    /** @ignore */\n\n  }, {\n    key: \"removeStyleLayers\",\n    value: function removeStyleLayers() {\n      var mbMap = this.mapboxLayer.mbMap;\n\n      if (!mbMap) {\n        return;\n      }\n\n      this.styleLayers.forEach(function (styleLayer) {\n        if (mbMap.getLayer(styleLayer.id)) {\n          mbMap.removeLayer(styleLayer.id);\n        }\n      });\n    }\n    /**\n     * On Mapbox map load callback function. Add style layers and dynaimc filters.\n     * @ignore\n     */\n\n  }, {\n    key: \"onLoad\",\n    value: function onLoad() {\n      this.addStyleLayers();\n\n      if (this.addDynamicFilters) {\n        this.addDynamicFilters();\n      }\n    }\n    /**\n     * Request feature information for a given coordinate.\n     * @param {ol/coordinate~Coordinate} coordinate Coordinate to request the information at.\n     * @returns {Promise<Object>} Promise with features, layer and coordinate\n     *  or null if no feature was hit.\n     */\n\n  }, {\n    key: \"getFeatureInfoAtCoordinate\",\n    value: function getFeatureInfoAtCoordinate(coordinate) {\n      var _this4 = this;\n\n      var mbMap = this.mapboxLayer.mbMap; // Ignore the getFeatureInfo until the mapbox map is loaded\n\n      if (!mbMap || !mbMap.isStyleLoaded()) {\n        return Promise.resolve({\n          coordinate: coordinate,\n          features: [],\n          layer: this\n        });\n      } // We query features only on style layers used by this layer.\n\n\n      var layers = this.styleLayers || [];\n\n      if (this.styleLayersFilter) {\n        layers = mbMap.getStyle().layers.filter(this.styleLayersFilter);\n      }\n\n      if (this.queryRenderedLayersFilter) {\n        layers = mbMap.getStyle().layers.filter(this.queryRenderedLayersFilter);\n      }\n\n      return this.mapboxLayer.getFeatureInfoAtCoordinate(coordinate, {\n        layers: layers.map(function (layer) {\n          return layer && layer.id;\n        }),\n        validate: false\n      }).then(function (featureInfo) {\n        var features = featureInfo.features.filter(function (feature) {\n          return _this4.featureInfoFilter(feature, _this4.map.getView().getResolution());\n        });\n\n        _this4.highlight(features);\n\n        return _objectSpread(_objectSpread({}, featureInfo), {}, {\n          features: features,\n          layer: _this4\n        });\n      });\n    }\n    /**\n     * Set filter that determines which features should be rendered in a style layer.\n     * @param {mapboxgl.filter} filter Determines which features should be rendered in a style layer.\n     */\n\n  }, {\n    key: \"setFilter\",\n    value: function setFilter(filter) {\n      var mbMap = this.mapboxLayer.mbMap;\n\n      if (!mbMap) {\n        return;\n      }\n\n      this.styleLayers.forEach(function (_ref2) {\n        var id = _ref2.id;\n\n        if (mbMap.getLayer(id)) {\n          mbMap.setFilter(id, filter);\n        }\n      });\n    }\n    /**\n     * Set if features are hovered or not.\n     * @param {Array<ol/Feature~Feature>} features\n     * @param {boolean} state Is the feature hovered\n     * @private\n     */\n\n  }, {\n    key: \"setHoverState\",\n    value: function setHoverState() {\n      var features = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var state = arguments.length > 1 ? arguments[1] : undefined;\n      var mbMap = this.mapboxLayer.mbMap;\n\n      if (!mbMap) {\n        return;\n      }\n\n      features.forEach(function (feature) {\n        var _ref3 = feature.get('mapboxFeature') || {},\n            source = _ref3.source,\n            sourceLayer = _ref3.sourceLayer;\n\n        if (!source && !sourceLayer || !feature.getId()) {\n          if (!feature.getId()) {\n            // eslint-disable-next-line no-console\n            console.warn(\"No feature's id found. To use the feature state functionnality, tiles must be generated with --generate-ids. See https://github.com/mapbox/tippecanoe#adding-calculated-attributes.\", feature.getId(), feature.getProperties());\n          }\n\n          return;\n        }\n\n        mbMap.setFeatureState({\n          id: feature.getId(),\n          source: source,\n          sourceLayer: sourceLayer\n        }, {\n          hover: state\n        });\n      });\n    }\n    /**\n     * Select a list of features.\n     * @param {Array<ol/Feature~Feature>} [features=[]] Features to select.\n     * @private\n     */\n\n  }, {\n    key: \"select\",\n    value: function select() {\n      var features = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      this.setHoverState(this.selectedFeatures, false);\n      this.selectedFeatures = features;\n      this.setHoverState(this.selectedFeatures, true);\n    }\n    /**\n     * Highlight a list of features.\n     * @param {Array<ol/Feature~Feature>} [features=[]] Features to highlight.\n     * @private\n     */\n\n  }, {\n    key: \"highlight\",\n    value: function highlight() {\n      var _this5 = this;\n\n      var features = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      // Filter out selected features\n      var filtered = this.highlightedFeatures.filter(function (feature) {\n        return !_this5.selectedFeatures.map(function (feat) {\n          return feat.getId();\n        }).includes(feature.getId());\n      }); // Remove previous highlight\n\n      this.setHoverState(filtered, false);\n      this.highlightedFeatures = features; // Add highlight\n\n      this.setHoverState(this.highlightedFeatures, true);\n    }\n    /**\n     * Create a copy of the MapboxStyleLayer.\n     * @param {Object} newOptions Options to override.\n     * @returns {MapboxStyleLayer} A MapboxStyleLayer.\n     */\n\n  }, {\n    key: \"clone\",\n    value: function clone(newOptions) {\n      return new MapboxStyleLayer(_objectSpread(_objectSpread({}, this.options), newOptions));\n    }\n  }]);\n\n  return MapboxStyleLayer;\n}(Layer);\n\nexport default MapboxStyleLayer;","map":{"version":3,"sources":["/home/daniel/gitRepos/danji90.github.io/node_modules/mobility-toolbox-js/ol/layers/MapboxStyleLayer.js"],"names":["Layer","applyLayoutVisibility","mbMap","visible","filterFunc","style","getStyle","visibilityValue","i","layers","length","styleLayer","getLayer","id","setLayoutProperty","MapboxStyleLayer","options","mapboxLayer","styleLayersFilter","beforeId","featureInfoFilter","obj","queryRenderedLayersFilter","highlightedFeatures","selectedFeatures","styleLayers","addStyleLayers","bind","onLoad","filters","addDynamicFilters","setFilter","ids","map","s","includes","init","olLayer","olListenersKeys","push","on","loaded","isStyleLoaded","once","layer","target","e","clickCallbacks","getFeatureInfoAtCoordinate","coordinate","then","d","callClickCallbacks","features","catch","forEach","c","off","removeStyleLayers","source","getSource","addLayer","removeLayer","Promise","resolve","filter","validate","featureInfo","feature","getView","getResolution","highlight","state","get","sourceLayer","getId","console","warn","getProperties","setFeatureState","hover","setHoverState","filtered","feat","newOptions"],"mappings":"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","sourcesContent":["/* eslint-disable no-param-reassign */\nimport Layer from './Layer';\n\n/**\n * Apply visibility to style layers that fits the filter function.\n * @private\n */\nconst applyLayoutVisibility = (mbMap, visible, filterFunc) => {\n  if (!mbMap) {\n    return;\n  }\n\n  const style = mbMap.getStyle();\n\n  if (!style) {\n    return;\n  }\n\n  if (filterFunc) {\n    const visibilityValue = visible ? 'visible' : 'none';\n    for (let i = 0; i < style.layers.length; i += 1) {\n      const styleLayer = style.layers[i];\n      if (filterFunc(styleLayer)) {\n        if (mbMap.getLayer(styleLayer.id)) {\n          mbMap.setLayoutProperty(styleLayer.id, 'visibility', visibilityValue);\n        }\n      }\n    }\n  }\n};\n\n/**\n * Layer for visualizing a specific set of layer from a MapboxLayer.\n *\n * @example\n * import { MapboxLayer, MapboxStyleLayer } from 'mobility-toolbox-js/ol';\n *\n * const mapboxLayer = new MapboxLayer({\n *   url: 'https://maps.geops.io/styles/travic_v2/style.json?key=[yourApiKey]',\n * });\n *\n * const layer = new MapboxStyleLayer({\n *   mapboxLayer: mapboxLayer,\n *   styleLayersFilter: () => {},\n * });\n *\n * @extends {Layer}\n */\nclass MapboxStyleLayer extends Layer {\n  /**\n   * Constructor.\n   *\n   * @param {Object} options\n   * @param {MapboxLayer} [options.mapboxLayer] The MapboxLayer to use.\n   * @param {Function} [options.styleLayersFilter] Filter function to decide which style layer to display.\n   */\n  constructor(options = {}) {\n    super(options);\n\n    /**\n     * MapboxLayer provided for the style Layer.\n     * @type {MapboxLayer}\n     * @private\n     */\n    this.mapboxLayer = options.mapboxLayer;\n\n    /**\n     * Function to filter features to be displayed.\n     * @type {function}\n     * @private\n     */\n    this.styleLayersFilter = options.styleLayersFilter;\n\n    /**\n     * Mapbox style layer id where to add the style layers.\n     * See [mapbox.map.addLayer](https://docs.mapbox.com/mapbox-gl-js/api/map/#map#addlayer) documentation.\n     * @type {String}\n     * @private\n     */\n    this.beforeId = options.beforeId;\n\n    /**\n     * Function to filter features for getFeatureInfoAtCoordinate method.\n     * @type {function}\n     * @private\n     */\n    this.featureInfoFilter = options.featureInfoFilter || ((obj) => obj);\n\n    /**\n     * Function to query the rendered features.\n     * @type {function}\n     * @private\n     */\n    this.queryRenderedLayersFilter = options.queryRenderedLayersFilter;\n\n    /**\n     * Array of features to highlight.\n     * @type {Array<ol/Feature~Feature>}\n     * @private\n     */\n    this.highlightedFeatures = [];\n\n    /**\n     * Array of selected features.\n     * @type {Array<ol/Feature~Feature>}\n     * @private\n     */\n    this.selectedFeatures = [];\n\n    /**\n     * Array of mapbox style layers to add.\n     * @type {Array<mapboxgl.styleLayer>}\n     * @private\n     */\n    this.styleLayers =\n      (options.styleLayer ? [options.styleLayer] : options.styleLayers) || [];\n\n    /**\n     * @private\n     */\n    this.addStyleLayers = this.addStyleLayers.bind(this);\n\n    /**\n     * @private\n     */\n    this.onLoad = this.onLoad.bind(this);\n    if (options.filters) {\n      /** @private */\n      this.addDynamicFilters = () => {\n        this.setFilter(\n          typeof options.filters === 'function'\n            ? options.filters(this)\n            : options.filters,\n        );\n      };\n    }\n\n    if (!this.styleLayersFilter && this.styleLayers) {\n      const ids = this.styleLayers.map((s) => s.id);\n      this.styleLayersFilter = (styleLayer) => {\n        return ids.includes(styleLayer.id);\n      };\n    }\n  }\n\n  /**\n   * Initialize the layer.\n   * @param {mapboxgl.Map} map the mapbox map.\n   * @override\n   */\n  init(map) {\n    if (!this.mapboxLayer.map) {\n      this.mapboxLayer.init(map);\n      /**\n       * An OpenLayers Layer.\n       * @type {ol/layer/Layer~Layer}\n       * @private\n       */\n      this.olLayer = this.mapboxLayer.olLayer;\n    }\n    super.init(map);\n\n    if (!this.map) {\n      return;\n    }\n\n    // Apply the initial visibiltity.\n    const { mbMap } = this.mapboxLayer;\n    if (!mbMap) {\n      // If the mbMap is not yet created because the  map has no target yet, we\n      // relaunch the initialisation when it's the case.\n      this.olListenersKeys.push(\n        this.map.on('change:target', () => {\n          this.init(map);\n        }),\n      );\n\n      return;\n    }\n\n    // mbMap.loaded() and mbMap.isStyleLoaded() are reliable only on the first call of init.\n    // On the next call (when a topic change for example), these functions returns false because\n    // the style is being modified.\n    // That's why we rely on a property instead for the next calls.\n    if (this.mapboxLayer.loaded || mbMap.isStyleLoaded() || mbMap.loaded()) {\n      this.onLoad();\n    } else {\n      mbMap.once('load', this.onLoad);\n    }\n\n    // Apply the visibiltity when layer's visibility change.\n    this.olListenersKeys.push(\n      this.on('change:visible', ({ target: layer }) => {\n        // Once the map is loaded we can apply vsiiblity without waiting\n        // the style. Mapbox take care of the application of style changes.\n        applyLayoutVisibility(mbMap, layer.visible, this.styleLayersFilter);\n      }),\n    );\n\n    this.olListenersKeys.push(\n      this.mapboxLayer.on('load', () => {\n        this.onLoad();\n      }),\n    );\n\n    // Listen to click events\n    this.olListenersKeys.push(\n      this.map.on('singleclick', (e) => {\n        if (!this.clickCallbacks.length) {\n          return;\n        }\n\n        this.getFeatureInfoAtCoordinate(e.coordinate)\n          .then((d) =>\n            this.callClickCallbacks(d.features, d.layer, d.coordinate),\n          )\n          .catch(() => this.callClickCallbacks([], this, e.coordinate));\n      }),\n    );\n  }\n\n  /**\n   * Call click callbacks with given parameters.\n   * This is done in a separate function for being able to modify the response.\n   * @param {Array<ol/Feature~Feature>} features\n   * @param {ol/layer/Layer~Layer} layer\n   * @param {ol/coordinate~Coordinate} coordinate\n   * @private\n   */\n  callClickCallbacks(features, layer, coordinate) {\n    this.clickCallbacks.forEach((c) => c(features, layer, coordinate));\n  }\n\n  /**\n   * Terminate the layer.\n   * @param {mapboxgl.Map} map the mapbox map.\n   * @override\n   */\n  terminate(map) {\n    const { mbMap } = this.mapboxLayer;\n    if (mbMap) {\n      mbMap.off('load', this.onLoad);\n      this.removeStyleLayers();\n    }\n    super.terminate(map);\n  }\n\n  /** @ignore */\n  addStyleLayers() {\n    const { mbMap } = this.mapboxLayer;\n\n    if (!mbMap) {\n      return;\n    }\n\n    this.styleLayers.forEach((styleLayer) => {\n      const { id, source } = styleLayer;\n      if (mbMap.getSource(source) && !mbMap.getLayer(id)) {\n        mbMap.addLayer(styleLayer, this.beforeId);\n      }\n    });\n    applyLayoutVisibility(mbMap, this.visible, this.styleLayersFilter);\n  }\n\n  /** @ignore */\n  removeStyleLayers() {\n    const { mbMap } = this.mapboxLayer;\n\n    if (!mbMap) {\n      return;\n    }\n\n    this.styleLayers.forEach((styleLayer) => {\n      if (mbMap.getLayer(styleLayer.id)) {\n        mbMap.removeLayer(styleLayer.id);\n      }\n    });\n  }\n\n  /**\n   * On Mapbox map load callback function. Add style layers and dynaimc filters.\n   * @ignore\n   */\n  onLoad() {\n    this.addStyleLayers();\n\n    if (this.addDynamicFilters) {\n      this.addDynamicFilters();\n    }\n  }\n\n  /**\n   * Request feature information for a given coordinate.\n   * @param {ol/coordinate~Coordinate} coordinate Coordinate to request the information at.\n   * @returns {Promise<Object>} Promise with features, layer and coordinate\n   *  or null if no feature was hit.\n   */\n  getFeatureInfoAtCoordinate(coordinate) {\n    const { mbMap } = this.mapboxLayer;\n\n    // Ignore the getFeatureInfo until the mapbox map is loaded\n    if (!mbMap || !mbMap.isStyleLoaded()) {\n      return Promise.resolve({ coordinate, features: [], layer: this });\n    }\n\n    // We query features only on style layers used by this layer.\n    let layers = this.styleLayers || [];\n\n    if (this.styleLayersFilter) {\n      layers = mbMap.getStyle().layers.filter(this.styleLayersFilter);\n    }\n\n    if (this.queryRenderedLayersFilter) {\n      layers = mbMap.getStyle().layers.filter(this.queryRenderedLayersFilter);\n    }\n\n    return this.mapboxLayer\n      .getFeatureInfoAtCoordinate(coordinate, {\n        layers: layers.map((layer) => layer && layer.id),\n        validate: false,\n      })\n      .then((featureInfo) => {\n        const features = featureInfo.features.filter((feature) => {\n          return this.featureInfoFilter(\n            feature,\n            this.map.getView().getResolution(),\n          );\n        });\n        this.highlight(features);\n        return { ...featureInfo, features, layer: this };\n      });\n  }\n\n  /**\n   * Set filter that determines which features should be rendered in a style layer.\n   * @param {mapboxgl.filter} filter Determines which features should be rendered in a style layer.\n   */\n  setFilter(filter) {\n    const { mbMap } = this.mapboxLayer;\n\n    if (!mbMap) {\n      return;\n    }\n\n    this.styleLayers.forEach(({ id }) => {\n      if (mbMap.getLayer(id)) {\n        mbMap.setFilter(id, filter);\n      }\n    });\n  }\n\n  /**\n   * Set if features are hovered or not.\n   * @param {Array<ol/Feature~Feature>} features\n   * @param {boolean} state Is the feature hovered\n   * @private\n   */\n  setHoverState(features = [], state) {\n    const { mbMap } = this.mapboxLayer;\n\n    if (!mbMap) {\n      return;\n    }\n\n    features.forEach((feature) => {\n      const { source, sourceLayer } = feature.get('mapboxFeature') || {};\n      if ((!source && !sourceLayer) || !feature.getId()) {\n        if (!feature.getId()) {\n          // eslint-disable-next-line no-console\n          console.warn(\n            \"No feature's id found. To use the feature state functionnality, tiles must be generated with --generate-ids. See https://github.com/mapbox/tippecanoe#adding-calculated-attributes.\",\n            feature.getId(),\n            feature.getProperties(),\n          );\n        }\n        return;\n      }\n\n      mbMap.setFeatureState(\n        {\n          id: feature.getId(),\n          source,\n          sourceLayer,\n        },\n        { hover: state },\n      );\n    });\n  }\n\n  /**\n   * Select a list of features.\n   * @param {Array<ol/Feature~Feature>} [features=[]] Features to select.\n   * @private\n   */\n  select(features = []) {\n    this.setHoverState(this.selectedFeatures, false);\n    this.selectedFeatures = features;\n    this.setHoverState(this.selectedFeatures, true);\n  }\n\n  /**\n   * Highlight a list of features.\n   * @param {Array<ol/Feature~Feature>} [features=[]] Features to highlight.\n   * @private\n   */\n  highlight(features = []) {\n    // Filter out selected features\n    const filtered = this.highlightedFeatures.filter((feature) => {\n      return !this.selectedFeatures\n        .map((feat) => feat.getId())\n        .includes(feature.getId());\n    });\n\n    // Remove previous highlight\n    this.setHoverState(filtered, false);\n    this.highlightedFeatures = features;\n\n    // Add highlight\n    this.setHoverState(this.highlightedFeatures, true);\n  }\n\n  /**\n   * Create a copy of the MapboxStyleLayer.\n   * @param {Object} newOptions Options to override.\n   * @returns {MapboxStyleLayer} A MapboxStyleLayer.\n   */\n  clone(newOptions) {\n    return new MapboxStyleLayer({ ...this.options, ...newOptions });\n  }\n}\n\nexport default MapboxStyleLayer;\n"]},"metadata":{},"sourceType":"module"}