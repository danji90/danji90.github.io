{"ast":null,"code":"import _slicedToArray from \"/home/daniel/gitRepos/danji90.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectSpread from \"/home/daniel/gitRepos/danji90.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _classCallCheck from \"/home/daniel/gitRepos/danji90.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/daniel/gitRepos/danji90.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { unByKey } from 'ol/Observable';\nimport GeomType from 'ol/geom/GeometryType';\n/**\n * Tracker. This class draw trajectories on a canvas.\n * @class\n * @param {Object} options\n * @private\n */\n\nvar Tracker = /*#__PURE__*/function () {\n  /**\n   * @private\n   */\n  function Tracker(options) {\n    _classCallCheck(this, Tracker);\n\n    var opts = _objectSpread({\n      interpolate: true\n    }, options);\n    /**\n     * Array of trajectories.\n     * @type {Array<trajectory>}\n     */\n\n\n    this.trajectories = [];\n    /**\n     * Array of trajectories that are currently drawn.\n     * @type {Array<key>}\n     */\n\n    this.renderedTrajectories = [];\n    /**\n     * Array of ol events key, returned by on() or once().\n     * @type {Array<key>}\n     */\n\n    this.interpolate = !!opts.interpolate;\n    /**\n     * Function to Convert coordinate to canvas pixel.\n     * @type {function}\n     */\n\n    this.getPixelFromCoordinate = opts.getPixelFromCoordinate;\n    /**\n     * Id of the trajectory which is hovered.\n     * @type {string}\n     */\n\n    this.hoverVehicleId = null;\n    /**\n     * Scale the vehicle icons with this value.\n     * @param {number}\n     */\n\n    this.iconScale = opts.iconScale; // we draw directly on the canvas since openlayers is too slow.\n\n    /**\n     * HTML <canvas> element.\n     * @type {Canvas}\n     */\n\n    this.canvas = opts.canvas || document.createElement('canvas');\n    this.canvas.width = opts.width;\n    this.canvas.height = opts.height;\n    this.canvas.setAttribute('style', ['position: absolute', 'top: 0', 'bottom: 0', 'right: 0', 'left: 0', 'pointer-events: none', 'visibility: visible', 'margin-top: inherit' // for scrolling behavior.\n    ].join(';'));\n    /**\n     * 2d drawing context on the canvas.\n     * @type {CanvasRenderingContext2D}\n     */\n\n    this.canvasContext = this.canvas.getContext('2d');\n  }\n  /**\n   * Set visibility of the canvas.\n   * @param {boolean} visible The visibility of the layer\n   */\n\n\n  _createClass(Tracker, [{\n    key: \"setVisible\",\n    value: function setVisible(visible) {\n      if (this.canvas) {\n        this.canvas.style.visibility = visible ? 'visible' : 'hidden';\n      }\n    }\n    /**\n     * Define the trajectories.\n     * @param {array<ol/Feature~Feature>} trajectories\n     */\n\n  }, {\n    key: \"setTrajectories\",\n    value: function setTrajectories() {\n      var trajectories = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (this.sort) {\n        trajectories.sort(this.sort);\n      }\n\n      this.trajectories = trajectories;\n    }\n    /**\n     * Return the trajectories.\n     * @returns {array<trajectory>} trajectories\n     */\n\n  }, {\n    key: \"getTrajectories\",\n    value: function getTrajectories() {\n      return this.trajectories || [];\n    }\n    /**\n     * Return rendered trajectories.\n     * Use this to avoid race conditions while rendering.\n     * @returns {array<trajectory>} trajectories\n     */\n\n  }, {\n    key: \"getRenderedTrajectories\",\n    value: function getRenderedTrajectories() {\n      return this.renderedTrajectories;\n    }\n    /**\n     * Clear the canvas.\n     * @private\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      if (this.canvasContext) {\n        this.canvasContext.clearRect(0, 0, this.canvas.width, this.canvas.height);\n      }\n    }\n    /**\n     * Set the filter for tracker features.\n     * @param {function} filter Filter function.\n     */\n\n  }, {\n    key: \"setFilter\",\n    value: function setFilter(filter) {\n      /**\n       * Current filter function.\n       * @type {function}\n       */\n      this.filter = filter;\n    }\n    /**\n     * Set the sort for tracker features.\n     * @param {function} sort Sort function.\n     */\n\n  }, {\n    key: \"setSort\",\n    value: function setSort(sort) {\n      /**\n       * The sort function for tracker features.\n       * @type {function}\n       */\n      this.sort = sort;\n    }\n    /**\n     * Set the id of the trajectory which is hovered.\n     * @param {string} id Id of a vehicle.\n     * @private\n     */\n\n  }, {\n    key: \"setHoverVehicleId\",\n    value: function setHoverVehicleId(id) {\n      if (id !== this.hoverVehicleId) {\n        this.hoverVehicleId = id;\n      }\n    }\n    /**\n     * set the scale of the vehicle icons.\n     * @param {number} iconScale Scale value.\n     */\n\n  }, {\n    key: \"setIconScale\",\n    value: function setIconScale(iconScale) {\n      this.iconScale = iconScale;\n    }\n    /**\n     * Set the tracker style.\n     * @param {function} s OpenLayers style function.\n     */\n\n  }, {\n    key: \"setStyle\",\n    value: function setStyle(s) {\n      /**\n       * Style function.\n       * @type {function}\n       */\n      this.style = s;\n    }\n    /**\n     * Draw all the trajectories available to the canvas.\n     * @param {Date} currTime The date to render.\n     * @param {number[2]} size Size ([width, height]) of the canvas to render.\n     * @param {number} resolution Which resolution of the map to render.\n     * @private\n     */\n\n  }, {\n    key: \"renderTrajectories\",\n    value: function renderTrajectories() {\n      var currTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Date.now();\n      var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var resolution = arguments.length > 2 ? arguments[2] : undefined;\n      this.clear();\n\n      var _size = _slicedToArray(size, 2),\n          width = _size[0],\n          height = _size[1];\n\n      if (width && height && (this.canvas.width !== width || this.canvas.height !== height)) {\n        var _ref = [width, height];\n        this.canvas.width = _ref[0];\n        this.canvas.height = _ref[1];\n      }\n      /**\n       * Current resolution.\n       * @type {number}\n       */\n\n\n      this.currResolution = resolution || this.currResolution;\n      var hoverVehicleImg;\n      var hoverVehiclePx;\n      var hoverVehicleWidth;\n      var hoverVehicleHeight;\n\n      for (var i = (this.trajectories || []).length - 1; i >= 0; i -= 1) {\n        var traj = this.trajectories[i]; // We simplify the traj object\n\n        var geometry = traj.geometry,\n            timeIntervals = traj.timeIntervals,\n            timeOffset = traj.timeOffset;\n\n        if (this.filter && !this.filter(traj)) {\n          // eslint-disable-next-line no-continue\n          continue;\n        }\n\n        var coord = null;\n        var rotation = void 0;\n\n        if (timeIntervals && timeIntervals.length > 1) {\n          var now = currTime - (timeOffset || 0);\n          var start = void 0;\n          var end = void 0;\n          var startFrac = void 0;\n          var endFrac = void 0;\n          var timeFrac = void 0; // Search th time interval.\n\n          for (var j = 0; j < timeIntervals.length - 1; j += 1) {\n            // Rotation only available in tralis layer.\n            var _timeIntervals$j = _slicedToArray(timeIntervals[j], 3);\n\n            start = _timeIntervals$j[0];\n            startFrac = _timeIntervals$j[1];\n            rotation = _timeIntervals$j[2];\n\n            var _timeIntervals = _slicedToArray(timeIntervals[j + 1], 2);\n\n            end = _timeIntervals[0];\n            endFrac = _timeIntervals[1];\n\n            if (start <= now && now <= end) {\n              break;\n            } else {\n              start = null;\n              end = null;\n            }\n          } // The geometry can also be a Point\n\n\n          if (geometry.getType() === GeomType.POINT) {\n            coord = geometry.getCoordinate();\n          } else if (geometry.getType() === GeomType.LINE_STRING) {\n            if (start && end) {\n              // interpolate position inside the time interval.\n              timeFrac = this.interpolate ? Math.min((now - start) / (end - start), 1) : 0;\n              var geomFrac = this.interpolate ? timeFrac * (endFrac - startFrac) + startFrac : 0;\n              coord = geometry.getCoordinateAt(geomFrac); // We set the rotation and the timeFraction of the trajectory (used by tralis).\n\n              this.trajectories[i].rotation = rotation;\n              this.trajectories[i].endFraction = timeFrac; // It happens that the now date was some ms before the first timeIntervals we have.\n            } else if (now < timeIntervals[0][0]) {\n              var _timeIntervals2 = _slicedToArray(timeIntervals, 1);\n\n              var _timeIntervals2$ = _slicedToArray(_timeIntervals2[0], 3);\n\n              rotation = _timeIntervals2$[2];\n              timeFrac = 0;\n              coord = geometry.getFirstCoordinate();\n            } else if (now > timeIntervals[timeIntervals.length - 1][0]) {\n              var _timeIntervals3 = _slicedToArray(timeIntervals[timeIntervals.length - 1], 3);\n\n              rotation = _timeIntervals3[2];\n              timeFrac = 1;\n              coord = geometry.getLastCoordinate();\n            }\n          } else {\n            // eslint-disable-next-line no-console\n            console.error('This geometry type is not supported. Only Point or LineString are. Current geometry: ', geometry);\n          } // We set the rotation and the timeFraction of the trajectory (used by tralis).\n          // if rotation === null that seems there is no rotation available.\n\n\n          this.trajectories[i].rotation = rotation;\n          this.trajectories[i].endFraction = timeFrac || 0;\n        }\n\n        if (coord) {\n          // We set the rotation of the trajectory (used by tralis).\n          this.trajectories[i].coordinate = coord;\n          var px = this.getPixelFromCoordinate(coord);\n\n          if (!px) {\n            // eslint-disable-next-line no-continue\n            continue;\n          } // Trajectory with pixel (i.e. within map extent) will be in renderedTrajectories.\n\n\n          this.trajectories[i].rendered = true;\n          var vehicleImg = this.style(traj, this.currResolution);\n          var imgWidth = vehicleImg.width;\n          var imgHeight = vehicleImg.height;\n\n          if (this.iconScale) {\n            imgHeight = Math.floor(imgHeight * this.iconScale);\n            imgWidth = Math.floor(imgWidth * this.iconScale);\n          }\n\n          if (this.hoverVehicleId !== traj.id) {\n            this.canvasContext.drawImage(vehicleImg, px[0] - imgWidth / 2, px[1] - imgHeight / 2, imgWidth, imgHeight);\n          } else {\n            // Store the canvas to draw it at the end\n            hoverVehicleImg = vehicleImg;\n            hoverVehiclePx = px;\n            hoverVehicleWidth = imgWidth;\n            hoverVehicleHeight = imgHeight;\n          }\n        }\n      }\n\n      if (hoverVehicleImg) {\n        this.canvasContext.drawImage(hoverVehicleImg, hoverVehiclePx[0] - hoverVehicleWidth / 2, hoverVehiclePx[1] - hoverVehicleHeight / 2, hoverVehicleWidth, hoverVehicleHeight);\n      }\n\n      this.renderedTrajectories = this.trajectories.filter(function (t) {\n        return t.rendered;\n      });\n    }\n    /**\n     * Clean the canvas and the events the tracker.\n     * @private\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      unByKey(this.olEventsKeys);\n      this.renderedTrajectories = [];\n      this.clear();\n    }\n  }]);\n\n  return Tracker;\n}();\n\nexport { Tracker as default };","map":{"version":3,"sources":["/home/daniel/gitRepos/danji90.github.io/node_modules/mobility-toolbox-js/common/Tracker.js"],"names":["unByKey","GeomType","Tracker","options","opts","interpolate","trajectories","renderedTrajectories","getPixelFromCoordinate","hoverVehicleId","iconScale","canvas","document","createElement","width","height","setAttribute","join","canvasContext","getContext","visible","style","visibility","sort","clearRect","filter","id","s","currTime","Date","now","size","resolution","clear","currResolution","hoverVehicleImg","hoverVehiclePx","hoverVehicleWidth","hoverVehicleHeight","i","length","traj","geometry","timeIntervals","timeOffset","coord","rotation","start","end","startFrac","endFrac","timeFrac","j","getType","POINT","getCoordinate","LINE_STRING","Math","min","geomFrac","getCoordinateAt","endFraction","getFirstCoordinate","getLastCoordinate","console","error","coordinate","px","rendered","vehicleImg","imgWidth","imgHeight","floor","drawImage","t","olEventsKeys"],"mappings":"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","sourcesContent":["import { unByKey } from 'ol/Observable';\nimport GeomType from 'ol/geom/GeometryType';\n\n/**\n * Tracker. This class draw trajectories on a canvas.\n * @class\n * @param {Object} options\n * @private\n */\nexport default class Tracker {\n  /**\n   * @private\n   */\n  constructor(options) {\n    const opts = {\n      interpolate: true,\n      ...options,\n    };\n\n    /**\n     * Array of trajectories.\n     * @type {Array<trajectory>}\n     */\n    this.trajectories = [];\n\n    /**\n     * Array of trajectories that are currently drawn.\n     * @type {Array<key>}\n     */\n    this.renderedTrajectories = [];\n\n    /**\n     * Array of ol events key, returned by on() or once().\n     * @type {Array<key>}\n     */\n    this.interpolate = !!opts.interpolate;\n\n    /**\n     * Function to Convert coordinate to canvas pixel.\n     * @type {function}\n     */\n    this.getPixelFromCoordinate = opts.getPixelFromCoordinate;\n\n    /**\n     * Id of the trajectory which is hovered.\n     * @type {string}\n     */\n    this.hoverVehicleId = null;\n\n    /**\n     * Scale the vehicle icons with this value.\n     * @param {number}\n     */\n    this.iconScale = opts.iconScale;\n\n    // we draw directly on the canvas since openlayers is too slow.\n    /**\n     * HTML <canvas> element.\n     * @type {Canvas}\n     */\n    this.canvas = opts.canvas || document.createElement('canvas');\n    this.canvas.width = opts.width;\n    this.canvas.height = opts.height;\n    this.canvas.setAttribute(\n      'style',\n      [\n        'position: absolute',\n        'top: 0',\n        'bottom: 0',\n        'right: 0',\n        'left: 0',\n        'pointer-events: none',\n        'visibility: visible',\n        'margin-top: inherit', // for scrolling behavior.\n      ].join(';'),\n    );\n    /**\n     * 2d drawing context on the canvas.\n     * @type {CanvasRenderingContext2D}\n     */\n    this.canvasContext = this.canvas.getContext('2d');\n  }\n\n  /**\n   * Set visibility of the canvas.\n   * @param {boolean} visible The visibility of the layer\n   */\n  setVisible(visible) {\n    if (this.canvas) {\n      this.canvas.style.visibility = visible ? 'visible' : 'hidden';\n    }\n  }\n\n  /**\n   * Define the trajectories.\n   * @param {array<ol/Feature~Feature>} trajectories\n   */\n  setTrajectories(trajectories = []) {\n    if (this.sort) {\n      trajectories.sort(this.sort);\n    }\n\n    this.trajectories = trajectories;\n  }\n\n  /**\n   * Return the trajectories.\n   * @returns {array<trajectory>} trajectories\n   */\n  getTrajectories() {\n    return this.trajectories || [];\n  }\n\n  /**\n   * Return rendered trajectories.\n   * Use this to avoid race conditions while rendering.\n   * @returns {array<trajectory>} trajectories\n   */\n  getRenderedTrajectories() {\n    return this.renderedTrajectories;\n  }\n\n  /**\n   * Clear the canvas.\n   * @private\n   */\n  clear() {\n    if (this.canvasContext) {\n      this.canvasContext.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    }\n  }\n\n  /**\n   * Set the filter for tracker features.\n   * @param {function} filter Filter function.\n   */\n  setFilter(filter) {\n    /**\n     * Current filter function.\n     * @type {function}\n     */\n    this.filter = filter;\n  }\n\n  /**\n   * Set the sort for tracker features.\n   * @param {function} sort Sort function.\n   */\n  setSort(sort) {\n    /**\n     * The sort function for tracker features.\n     * @type {function}\n     */\n    this.sort = sort;\n  }\n\n  /**\n   * Set the id of the trajectory which is hovered.\n   * @param {string} id Id of a vehicle.\n   * @private\n   */\n  setHoverVehicleId(id) {\n    if (id !== this.hoverVehicleId) {\n      this.hoverVehicleId = id;\n    }\n  }\n\n  /**\n   * set the scale of the vehicle icons.\n   * @param {number} iconScale Scale value.\n   */\n  setIconScale(iconScale) {\n    this.iconScale = iconScale;\n  }\n\n  /**\n   * Set the tracker style.\n   * @param {function} s OpenLayers style function.\n   */\n  setStyle(s) {\n    /**\n     * Style function.\n     * @type {function}\n     */\n    this.style = s;\n  }\n\n  /**\n   * Draw all the trajectories available to the canvas.\n   * @param {Date} currTime The date to render.\n   * @param {number[2]} size Size ([width, height]) of the canvas to render.\n   * @param {number} resolution Which resolution of the map to render.\n   * @private\n   */\n  renderTrajectories(currTime = Date.now(), size = [], resolution) {\n    this.clear();\n    const [width, height] = size;\n    if (\n      width &&\n      height &&\n      (this.canvas.width !== width || this.canvas.height !== height)\n    ) {\n      [this.canvas.width, this.canvas.height] = [width, height];\n    }\n    /**\n     * Current resolution.\n     * @type {number}\n     */\n    this.currResolution = resolution || this.currResolution;\n    let hoverVehicleImg;\n    let hoverVehiclePx;\n    let hoverVehicleWidth;\n    let hoverVehicleHeight;\n\n    for (let i = (this.trajectories || []).length - 1; i >= 0; i -= 1) {\n      const traj = this.trajectories[i];\n\n      // We simplify the traj object\n      const { geometry, timeIntervals, timeOffset } = traj;\n\n      if (this.filter && !this.filter(traj)) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      let coord = null;\n      let rotation;\n\n      if (timeIntervals && timeIntervals.length > 1) {\n        const now = currTime - (timeOffset || 0);\n        let start;\n        let end;\n        let startFrac;\n        let endFrac;\n        let timeFrac;\n\n        // Search th time interval.\n        for (let j = 0; j < timeIntervals.length - 1; j += 1) {\n          // Rotation only available in tralis layer.\n          [start, startFrac, rotation] = timeIntervals[j];\n          [end, endFrac] = timeIntervals[j + 1];\n\n          if (start <= now && now <= end) {\n            break;\n          } else {\n            start = null;\n            end = null;\n          }\n        }\n        // The geometry can also be a Point\n        if (geometry.getType() === GeomType.POINT) {\n          coord = geometry.getCoordinate();\n        } else if (geometry.getType() === GeomType.LINE_STRING) {\n          if (start && end) {\n            // interpolate position inside the time interval.\n            timeFrac = this.interpolate\n              ? Math.min((now - start) / (end - start), 1)\n              : 0;\n\n            const geomFrac = this.interpolate\n              ? timeFrac * (endFrac - startFrac) + startFrac\n              : 0;\n\n            coord = geometry.getCoordinateAt(geomFrac);\n\n            // We set the rotation and the timeFraction of the trajectory (used by tralis).\n            this.trajectories[i].rotation = rotation;\n            this.trajectories[i].endFraction = timeFrac;\n\n            // It happens that the now date was some ms before the first timeIntervals we have.\n          } else if (now < timeIntervals[0][0]) {\n            [[, , rotation]] = timeIntervals;\n            timeFrac = 0;\n            coord = geometry.getFirstCoordinate();\n          } else if (now > timeIntervals[timeIntervals.length - 1][0]) {\n            [, , rotation] = timeIntervals[timeIntervals.length - 1];\n            timeFrac = 1;\n            coord = geometry.getLastCoordinate();\n          }\n        } else {\n          // eslint-disable-next-line no-console\n          console.error(\n            'This geometry type is not supported. Only Point or LineString are. Current geometry: ',\n            geometry,\n          );\n        }\n\n        // We set the rotation and the timeFraction of the trajectory (used by tralis).\n        // if rotation === null that seems there is no rotation available.\n        this.trajectories[i].rotation = rotation;\n        this.trajectories[i].endFraction = timeFrac || 0;\n      }\n\n      if (coord) {\n        // We set the rotation of the trajectory (used by tralis).\n        this.trajectories[i].coordinate = coord;\n        const px = this.getPixelFromCoordinate(coord);\n\n        if (!px) {\n          // eslint-disable-next-line no-continue\n          continue;\n        }\n        // Trajectory with pixel (i.e. within map extent) will be in renderedTrajectories.\n        this.trajectories[i].rendered = true;\n\n        const vehicleImg = this.style(traj, this.currResolution);\n        let imgWidth = vehicleImg.width;\n        let imgHeight = vehicleImg.height;\n\n        if (this.iconScale) {\n          imgHeight = Math.floor(imgHeight * this.iconScale);\n          imgWidth = Math.floor(imgWidth * this.iconScale);\n        }\n\n        if (this.hoverVehicleId !== traj.id) {\n          this.canvasContext.drawImage(\n            vehicleImg,\n            px[0] - imgWidth / 2,\n            px[1] - imgHeight / 2,\n            imgWidth,\n            imgHeight,\n          );\n        } else {\n          // Store the canvas to draw it at the end\n          hoverVehicleImg = vehicleImg;\n          hoverVehiclePx = px;\n          hoverVehicleWidth = imgWidth;\n          hoverVehicleHeight = imgHeight;\n        }\n      }\n    }\n    if (hoverVehicleImg) {\n      this.canvasContext.drawImage(\n        hoverVehicleImg,\n        hoverVehiclePx[0] - hoverVehicleWidth / 2,\n        hoverVehiclePx[1] - hoverVehicleHeight / 2,\n        hoverVehicleWidth,\n        hoverVehicleHeight,\n      );\n    }\n\n    this.renderedTrajectories = this.trajectories.filter((t) => t.rendered);\n  }\n\n  /**\n   * Clean the canvas and the events the tracker.\n   * @private\n   */\n  destroy() {\n    unByKey(this.olEventsKeys);\n    this.renderedTrajectories = [];\n    this.clear();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}