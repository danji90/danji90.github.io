{"ast":null,"code":"import _classCallCheck from \"/home/daniel/gitRepos/danji90.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/daniel/gitRepos/danji90.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport WebSocketConnector from './WebSocketConnector';\nimport { getModeSuffix, cleanStopTime, compareDepartures } from './TralisAPIUtils';\n/**\n * Enum for Tralis modes.\n * @readonly\n * @typedef {string} TralisMode\n * @property {string} RAW \"raw\"\n * @property {string} SCHEMATIC \"schematic\"\n * @property {string} TOPOGRAPHIC \"topographic\"\n * @enum {TralisMode}\n */\n\nexport var TralisModes = {\n  RAW: 'raw',\n  TOPOGRAPHIC: 'topographic',\n  SCHEMATIC: 'schematic'\n};\n/**\n * Access to Tralis service.\n *\n * @example\n * import { TralisAPI } from 'mobility-toolbox-js/api';\n *\n * const api = new TralisAPI({\n *   url: \"yourUrl\",\n *   apiKey: \"yourApiKey\"\n * });\n *\n * @example\n * import { TralisAPI } from 'mobility-toolbox-js/api';\n *\n * const api = new TralisAPI(\"yourUrl\");\n */\n\nvar TralisAPI = /*#__PURE__*/function () {\n  /**\n   * Constructor\n   *\n   * @param {Object|string} options A string representing the url of the service or an object containing the url and the apiKey.\n   * @param {string} options.url Service url.\n   * @param {string} options.apiKey Access key for [geOps services](https://developer.geops.io/).\n   * @param {string} [options.projection='epsg:3857'] The epsg code of the projection for features.\n   */\n  function TralisAPI() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, TralisAPI);\n\n    var wsUrl = null;\n\n    if (typeof options === 'string') {\n      wsUrl = options;\n    } else {\n      wsUrl = options.url;\n    }\n\n    if (options.apiKey) {\n      wsUrl = \"\".concat(wsUrl, \"?key=\").concat(options.apiKey);\n    }\n    /** @ignore */\n\n\n    this.conn = new WebSocketConnector(wsUrl);\n    this.conn.setProjection(options.projection || 'epsg:3857');\n    /** @ignore */\n\n    this.subscribedStationUic = null;\n    /** @ignore */\n\n    this.departureUpdateTimeout = null;\n    /** @ignore */\n\n    this.maxDepartureAge = 30;\n    /** @ignore */\n\n    this.extraGeoms = {};\n  }\n  /**\n   * Subscribe to a channel.\n   *\n   * @param {string} channel Name of the websocket channel to subscribe.\n   * @param {function} onSuccess Callback when the subscription succeeds.\n   * @param {function} onError Callback when the subscription fails.\n   * @param {boolean} [quiet=false] If true avoid to store the subscription in the subscriptions list.\n   * @private\n   */\n\n\n  _createClass(TralisAPI, [{\n    key: \"subscribe\",\n    value: function subscribe(channel, onSuccess, onError) {\n      var quiet = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      this.conn.subscribe({\n        channel: channel\n      }, onSuccess, onError, quiet);\n    }\n    /**\n     * Unsubscribe to a channel.\n     *\n     * @param {string} channel Name of the websocket channel to unsubscribe.\n     * @param {string} [suffix=''] Suffix to add to the channel name.\n     * @private\n     */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(channel) {\n      var suffix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      this.conn.unsubscribe(\"\".concat(channel).concat(getModeSuffix(TralisModes.SCHEMATIC, TralisModes)).concat(suffix));\n      this.conn.unsubscribe(\"\".concat(channel).concat(getModeSuffix(TralisModes.TOPOGRAPHIC, TralisModes)).concat(suffix));\n    }\n    /**\n     * Filter departures and return an array.\n     *\n     * @param {Object} depObject The object containing departures by id.\n     * @param {boolean} [sortByMinArrivalTime=false] If true sort departures by arrival time.\n     * @returns {Array<departure>} Return departures array.\n     * @private\n     */\n\n  }, {\n    key: \"filterDepartures\",\n    value: function filterDepartures(depObject) {\n      var sortByMinArrivalTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var departures = Object.keys(depObject).map(function (k) {\n        return depObject[k];\n      });\n      departures.sort(function (a, b) {\n        return compareDepartures(a, b, sortByMinArrivalTime);\n      });\n      var future = new Date();\n      future.setMinutes(future.getMinutes() + this.maxDepartureAge);\n      future = future.getTime();\n      var past = new Date();\n      past.setMinutes(past.getMinutes() - this.maxDepartureAge);\n      past = past.getTime();\n      var departureArray = [];\n      var platformsBoarding = [];\n      var previousDeparture = null;\n\n      for (var i = departures.length - 1; i >= 0; i -= 1) {\n        var d = departures[i];\n        var t = new Date(d.time).getTime(); // Only show departures within the next 30 minutes\n\n        if (t > past && t < future) {\n          // If 2 trains are boarding at the same platform,\n          // remove the older one.\n          if (d.state === 'BOARDING') {\n            if (platformsBoarding.indexOf(d.platform) === -1) {\n              platformsBoarding.push(d.platform);\n            } else {\n              d.state = 'HIDDEN';\n            }\n          } // If two trains with the same line number and destinatin\n          // and a departure difference < 1 minute, hide the second one.\n\n\n          if (previousDeparture && d.to[0] === previousDeparture.to[0] && Math.abs(t - previousDeparture.time) < 1000 && d.line.name === previousDeparture.line.name) {\n            d.state = 'HIDDEN';\n          }\n\n          if (/(STOP_CANCELLED|JOURNEY_CANCELLED)/.test(d.state)) {\n            d.cancelled = true;\n          }\n\n          previousDeparture = d;\n          previousDeparture.time = t;\n          departureArray.unshift(d);\n        }\n      }\n\n      return departureArray;\n    }\n    /**\n     * Subscribe to departures channel of a given station.\n     *\n     * @param {number} stationId UIC of the station.\n     * @param {Boolean} sortByMinArrivalTime Sort by minimum arrival time\n     * @param {function(departures:Departure[])} onMessage Function called on each message of the channel.\n     */\n\n  }, {\n    key: \"subscribeDepartures\",\n    value: function subscribeDepartures(stationId) {\n      var _this = this;\n\n      var sortByMinArrivalTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var onMessage = arguments.length > 2 ? arguments[2] : undefined;\n      window.clearTimeout(this.departureUpdateTimeout);\n      this.unsubscribeDepartures();\n      this.subscribedStationUic = stationId;\n      var channel = stationId ? \"timetable_\".concat(stationId) : null;\n      var departureObject = {};\n      this.subscribe(channel, function (data) {\n        if (data.source === channel) {\n          var content = data.content || {};\n          var tDiff = new Date(content.timestamp).getTime() - Date.now();\n          content.timediff = tDiff;\n          departureObject[content.call_id] = content;\n          window.clearTimeout(_this.departureUpdateTimeout);\n          _this.departureUpdateTimeout = window.setTimeout(function () {\n            var departures = _this.filterDepartures(departureObject, sortByMinArrivalTime);\n\n            onMessage(departures);\n          }, 100);\n        }\n      }, function () {\n        onMessage([]);\n      });\n    }\n    /**\n     * Unsubscribe from current departures channel.\n     */\n\n  }, {\n    key: \"unsubscribeDepartures\",\n    value: function unsubscribeDepartures() {\n      if (this.subscribedStationUic) {\n        this.unsubscribe(\"timetable_\".concat(this.subscribedStationUic));\n        this.subscribedStationUic = null;\n      }\n    }\n    /**\n     * Subscribe to the disruptions channel.\n     *\n     * @param {function} onMessage Function called on each message of the channel.\n     */\n\n  }, {\n    key: \"subscribeDisruptions\",\n    value: function subscribeDisruptions(onMessage) {\n      this.subscribe('newsticker', function (data) {\n        onMessage(data.content);\n      });\n    }\n    /**\n     * Unsubscribe disruptions.\n     */\n\n  }, {\n    key: \"unsubscribeDisruptions\",\n    value: function unsubscribeDisruptions() {\n      this.unsubscribe('newsticker');\n    }\n    /**\n     * Return a station with a given uic number and a mode.\n     *\n     * @param {number} uic UIC of the station.\n     * @param {TralisMode} mode Tralis mode.\n     * @returns {Promise<Station>} A station.\n     */\n\n  }, {\n    key: \"getStation\",\n    value: function getStation(uic, mode) {\n      var _this2 = this;\n\n      var params = {\n        channel: \"station\".concat(getModeSuffix(mode, TralisModes)),\n        args: uic\n      };\n      return new Promise(function (resolve, reject) {\n        _this2.conn.get(params, function (data) {\n          if (data.content) {\n            resolve(data.content);\n          } else {\n            reject();\n          }\n        });\n      });\n    }\n    /**\n     * Update the model's station list for a given mode and a bbox.\n     *\n     * @param {TralisMode} mode Tralis mode.\n     * @param {number[4]} bbox The extent where to request.\n     * @returns {Promise<Station[]>} An array of stations.\n     */\n\n  }, {\n    key: \"getStations\",\n    value: function getStations(mode, bbox) {\n      var _this3 = this;\n\n      var stations = [];\n\n      if (bbox) {\n        this.conn.setBbox(bbox);\n      }\n\n      var params = {\n        channel: \"station\".concat(getModeSuffix(mode, TralisModes))\n      };\n      window.clearTimeout(this.stationUpdateTimeout);\n      return new Promise(function (resolve, reject) {\n        _this3.conn.get(params, function (data) {\n          if (data.content) {\n            stations.push(data.content);\n            window.clearTimeout(_this3.stationUpdateTimeout);\n            /** @ignore */\n\n            _this3.stationUpdateTimeout = window.setTimeout(function () {\n              resolve(stations);\n            }, 50);\n          } else {\n            reject(data.content);\n          }\n        });\n      });\n    }\n    /**\n     * Subscribe to stations channel.\n     * One message pro station.\n     *\n     * @param {TralisMode} mode Tralis mode.\n     * @param {number[4]} bbox The extent where to request.\n     * @param {function(station: Station)} onMessage Function called on each message of the channel.\n     */\n\n  }, {\n    key: \"subscribeStations\",\n    value: function subscribeStations(mode, bbox, onMessage) {\n      this.unsubscribeStations();\n\n      if (bbox) {\n        this.conn.setBbox(bbox);\n      }\n\n      this.subscribe(\"station\".concat(getModeSuffix(mode, TralisModes)), function (data) {\n        if (data.content) {\n          onMessage(data.content);\n        }\n      });\n    }\n    /**\n     * Unsubscribe to stations channel.\n     */\n\n  }, {\n    key: \"unsubscribeStations\",\n    value: function unsubscribeStations() {\n      window.clearTimeout(this.stationUpdateTimeout);\n      this.unsubscribe('station');\n    }\n    /**\n     * Subscribe to extra_geoms channel.\n     *\n     * @param {function(extraGeoms: GeosJSONFeature[])} onMessage Function called on each message of the channel.\n     */\n\n  }, {\n    key: \"subscribeExtraGeoms\",\n    value: function subscribeExtraGeoms(onMessage) {\n      var _this4 = this;\n\n      this.subscribe('extra_geoms', function (data) {\n        var extraGeom = data.content;\n\n        if (extraGeom) {\n          var ref = extraGeom.properties.ref;\n\n          if (extraGeom.type === 'Feature') {\n            _this4.extraGeoms[ref] = extraGeom;\n          } else {\n            delete _this4.extraGeoms[ref];\n          }\n\n          onMessage(Object.keys(_this4.extraGeoms).map(function (key) {\n            return _this4.extraGeoms[key];\n          }));\n        }\n      });\n    }\n    /**\n     * Unsubscribe to extra_geoms channel.\n     */\n\n  }, {\n    key: \"unsubscribeExtraGeoms\",\n    value: function unsubscribeExtraGeoms() {\n      this.unsubscribe('extra_geoms');\n    }\n    /**\n     * Subscribe to trajectory channel.\n     *\n     * @param {TralisMode} mode Tralis mode.\n     * @param {function(trajectory: TralisTrajectory)} onMessage Function called on each message of the channel.\n     */\n\n  }, {\n    key: \"subscribeTrajectory\",\n    value: function subscribeTrajectory(mode, onMessage) {\n      this.unsubscribeTrajectory();\n      this.subscribe(\"trajectory\".concat(getModeSuffix(mode, TralisModes)), onMessage);\n    }\n    /**\n     * Unsubscribe to trajectory channels.\n     */\n\n  }, {\n    key: \"unsubscribeTrajectory\",\n    value: function unsubscribeTrajectory() {\n      this.unsubscribe(\"trajectory\");\n    }\n    /**\n     * Subscribe to deleted_vhicles channel.\n     *\n     * @param {TralisMode} mode Tralis mode.\n     * @param {function(response: { content: Vehicle })} onMessage Function called on each message of the channel.\n     */\n\n  }, {\n    key: \"subscribeDeletedVehicles\",\n    value: function subscribeDeletedVehicles(mode, onMessage) {\n      this.unsubscribeDeletedVehicles();\n      this.subscribe(\"deleted_vehicles\".concat(getModeSuffix(mode, TralisModes)), onMessage);\n    }\n    /**\n     * Unsubscribe to deleted_vhicles channels.\n     */\n\n  }, {\n    key: \"unsubscribeDeletedVehicles\",\n    value: function unsubscribeDeletedVehicles() {\n      this.unsubscribe('deleted_vehicles');\n    }\n    /**\n     * Get a full trajectory of a vehicule .\n     *\n     * @param {number} id A vehicle id.\n     * @param {TralisMode} mode Tralis mode.\n     * @returns {Promise<FullTrajectory>} Return a full trajectory.\n     */\n\n  }, {\n    key: \"getFullTrajectory\",\n    value: function getFullTrajectory(id, mode) {\n      var _this5 = this;\n\n      var params = {\n        channel: \"full_trajectory\".concat(getModeSuffix(mode, TralisModes), \"_\").concat(id)\n      };\n      return new Promise(function (resolve) {\n        _this5.conn.get(params, function (data) {\n          if (data.content) {\n            resolve(data.content);\n          }\n        });\n      });\n    }\n    /**\n     * Get full trajectories of a vehicules .\n     *\n     * @param {number[]} ids List of vehicles ids.\n     * @param {TralisMode} mode Tralis mode.\n     * @returns {Promise<FullTrajectory[]>} Return an array of full trajectories.\n     */\n\n  }, {\n    key: \"getFullTrajectories\",\n    value: function getFullTrajectories(ids, mode) {\n      var _this6 = this;\n\n      var promises = ids.map(function (id) {\n        return _this6.getFullTrajectory(id, mode);\n      });\n      return Promise.all(promises);\n    }\n    /**\n     * Subscribe to full_trajectory channel of a given vehicle.\n     *\n     * @param {number} id A vehicle id.\n     * @param {TralisMode} mode Tralis mode.\n     */\n\n  }, {\n    key: \"subscribeFullTrajectory\",\n    value: function subscribeFullTrajectory(id, mode) {\n      // window.clearTimeout(this.fullTrajectoryUpdateTimeout);\n      this.unsubscribeFullTrajectory(id);\n      this.subscribe(\"full_trajectory\".concat(getModeSuffix(mode, TralisModes), \"_\").concat(id), function (data) {\n        // eslint-disable-next-line no-console\n        console.log('subscribe full_trajectory', data);\n      }, function (err) {\n        // eslint-disable-next-line no-console\n        console.log('subscribe full_trajectory error', err);\n      });\n    }\n    /**\n     * Unsubscribe from full_trajectory channel\n     *\n     * @param {number} id A vehicle id.\n     */\n\n  }, {\n    key: \"unsubscribeFullTrajectory\",\n    value: function unsubscribeFullTrajectory(id) {\n      this.unsubscribe('full_trajectory', \"_\".concat(id));\n    }\n    /**\n     * Get the list of stops for this vehicle.\n     *\n     * @param {number} id A vehicle id.\n     * @param {TralisMode} mode Tralis mode.\n     * @returns {Promise<StopSequence>} Returns a stop sequence object.\n     */\n\n  }, {\n    key: \"getStopSequence\",\n    value: function getStopSequence(id, mode) {\n      var _this7 = this;\n\n      var params = {\n        channel: \"stopsequence\".concat(getModeSuffix(mode, TralisModes), \"_\").concat(id)\n      };\n      return new Promise(function (resolve, reject) {\n        _this7.conn.get(params, function (data) {\n          // Remove the delay from arrivalTime nad departureTime\n          resolve(cleanStopTime(data.content && data.content[0]));\n        }, function (err) {\n          reject(err);\n        });\n      });\n    }\n    /**\n     * Get a list of stops for a list of vehicles.\n     *\n     * @param {number[]} ids List of vehicles ids.\n     * @param {TralisMode} mode Tralis mode.\n     * @returns {Promise<StopSequence[]>} Return an array of stop sequences.\n     */\n\n  }, {\n    key: \"getStopSequences\",\n    value: function getStopSequences(ids, mode) {\n      var _this8 = this;\n\n      var promises = ids.map(function (id) {\n        return _this8.getStopSequence(id, mode);\n      });\n      return Promise.all(promises);\n    }\n    /**\n     * Subscribe to stopsequence channel of a given vehicle.\n     *\n     * @param {number} id A vehicle id.\n     * @param {TralisMode} mode Tralis mode.\n     * @param {function(stopSequence: StopSequence)} onMessage Function called on each message of the channel.\n     */\n\n  }, {\n    key: \"subscribeStopSequence\",\n    value: function subscribeStopSequence(id, mode, onMessage) {\n      window.clearTimeout(this.fullTrajectoryUpdateTimeout);\n      this.unsubscribeStopSequence(id);\n      this.subscribe(\"stopsequence\".concat(getModeSuffix(mode, TralisModes), \"_\").concat(id), function (data) {\n        // Remove the delay from arrivalTime nad departureTime\n        onMessage(cleanStopTime(data.content && data.content[0]));\n      }, function (err) {\n        // eslint-disable-next-line no-console\n        console.log('subscribe stopsequence error', err);\n      });\n    }\n    /**\n     * Unsubscribe from stopsequence channel\n     *\n     * @param {number} id A vehicle id.\n     */\n\n  }, {\n    key: \"unsubscribeStopSequence\",\n    value: function unsubscribeStopSequence(id) {\n      this.unsubscribe(\"stopsequence\", \"_\".concat(id));\n    }\n    /**\n     * Subscribe to healthcheck channel.\n     * @param {function} onMessage Callback when the subscribe to healthcheck channel succeeds.\n     */\n\n  }, {\n    key: \"subscribeHealthCheck\",\n    value: function subscribeHealthCheck(onMessage) {\n      this.unsubscribeHealthCheck();\n      this.subscribe('healthcheck', onMessage);\n    }\n    /**\n     * Unsubscribe to healthcheck channel.\n     */\n\n  }, {\n    key: \"unsubscribeHealthCheck\",\n    value: function unsubscribeHealthCheck() {\n      this.unsubscribe('healthcheck');\n    }\n  }]);\n\n  return TralisAPI;\n}();\n\nexport default TralisAPI;","map":{"version":3,"sources":["/home/daniel/gitRepos/danji90.github.io/node_modules/mobility-toolbox-js/api/tralis/TralisAPI.js"],"names":["WebSocketConnector","getModeSuffix","cleanStopTime","compareDepartures","TralisModes","RAW","TOPOGRAPHIC","SCHEMATIC","TralisAPI","options","wsUrl","url","apiKey","conn","setProjection","projection","subscribedStationUic","departureUpdateTimeout","maxDepartureAge","extraGeoms","channel","onSuccess","onError","quiet","subscribe","suffix","unsubscribe","depObject","sortByMinArrivalTime","departures","Object","keys","map","k","sort","a","b","future","Date","setMinutes","getMinutes","getTime","past","departureArray","platformsBoarding","previousDeparture","i","length","d","t","time","state","indexOf","platform","push","to","Math","abs","line","name","test","cancelled","unshift","stationId","onMessage","window","clearTimeout","unsubscribeDepartures","departureObject","data","source","content","tDiff","timestamp","now","timediff","call_id","setTimeout","filterDepartures","uic","mode","params","args","Promise","resolve","reject","get","bbox","stations","setBbox","stationUpdateTimeout","unsubscribeStations","extraGeom","ref","properties","type","key","unsubscribeTrajectory","unsubscribeDeletedVehicles","id","ids","promises","getFullTrajectory","all","unsubscribeFullTrajectory","console","log","err","getStopSequence","fullTrajectoryUpdateTimeout","unsubscribeStopSequence","unsubscribeHealthCheck"],"mappings":";;AAAA,OAAOA,kBAAP,MAA+B,sBAA/B;AACA,SACEC,aADF,EAEEC,aAFF,EAGEC,iBAHF,QAIO,kBAJP;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAMC,WAAW,GAAG;AACzBC,EAAAA,GAAG,EAAE,KADoB;AAEzBC,EAAAA,WAAW,EAAE,aAFY;AAGzBC,EAAAA,SAAS,EAAE;AAHc,CAApB;AAMP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IACMC,S;AACJ;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACE,uBAA0B;AAAA,QAAdC,OAAc,uEAAJ,EAAI;;AAAA;;AACxB,QAAIC,KAAK,GAAG,IAAZ;;AACA,QAAI,OAAOD,OAAP,KAAmB,QAAvB,EAAiC;AAC/BC,MAAAA,KAAK,GAAGD,OAAR;AACD,KAFD,MAEO;AACLC,MAAAA,KAAK,GAAGD,OAAO,CAACE,GAAhB;AACD;;AACD,QAAIF,OAAO,CAACG,MAAZ,EAAoB;AAClBF,MAAAA,KAAK,aAAMA,KAAN,kBAAmBD,OAAO,CAACG,MAA3B,CAAL;AACD;AACD;;;AACA,SAAKC,IAAL,GAAY,IAAIb,kBAAJ,CAAuBU,KAAvB,CAAZ;AACA,SAAKG,IAAL,CAAUC,aAAV,CAAwBL,OAAO,CAACM,UAAR,IAAsB,WAA9C;AACA;;AACA,SAAKC,oBAAL,GAA4B,IAA5B;AACA;;AACA,SAAKC,sBAAL,GAA8B,IAA9B;AACA;;AACA,SAAKC,eAAL,GAAuB,EAAvB;AACA;;AACA,SAAKC,UAAL,GAAkB,EAAlB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;WACE,mBAAUC,OAAV,EAAmBC,SAAnB,EAA8BC,OAA9B,EAAsD;AAAA,UAAfC,KAAe,uEAAP,KAAO;AACpD,WAAKV,IAAL,CAAUW,SAAV,CAAoB;AAAEJ,QAAAA,OAAO,EAAPA;AAAF,OAApB,EAAiCC,SAAjC,EAA4CC,OAA5C,EAAqDC,KAArD;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,qBAAYH,OAAZ,EAAkC;AAAA,UAAbK,MAAa,uEAAJ,EAAI;AAChC,WAAKZ,IAAL,CAAUa,WAAV,WACKN,OADL,SACenB,aAAa,CAACG,WAAW,CAACG,SAAb,EAAwBH,WAAxB,CAD5B,SACmEqB,MADnE;AAGA,WAAKZ,IAAL,CAAUa,WAAV,WACKN,OADL,SACenB,aAAa,CACxBG,WAAW,CAACE,WADY,EAExBF,WAFwB,CAD5B,SAIMqB,MAJN;AAMD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,0BAAiBE,SAAjB,EAA0D;AAAA,UAA9BC,oBAA8B,uEAAP,KAAO;AACxD,UAAMC,UAAU,GAAGC,MAAM,CAACC,IAAP,CAAYJ,SAAZ,EAAuBK,GAAvB,CAA2B,UAACC,CAAD;AAAA,eAAON,SAAS,CAACM,CAAD,CAAhB;AAAA,OAA3B,CAAnB;AACAJ,MAAAA,UAAU,CAACK,IAAX,CAAgB,UAACC,CAAD,EAAIC,CAAJ;AAAA,eAAUjC,iBAAiB,CAACgC,CAAD,EAAIC,CAAJ,EAAOR,oBAAP,CAA3B;AAAA,OAAhB;AAEA,UAAIS,MAAM,GAAG,IAAIC,IAAJ,EAAb;AACAD,MAAAA,MAAM,CAACE,UAAP,CAAkBF,MAAM,CAACG,UAAP,KAAsB,KAAKtB,eAA7C;AACAmB,MAAAA,MAAM,GAAGA,MAAM,CAACI,OAAP,EAAT;AAEA,UAAIC,IAAI,GAAG,IAAIJ,IAAJ,EAAX;AACAI,MAAAA,IAAI,CAACH,UAAL,CAAgBG,IAAI,CAACF,UAAL,KAAoB,KAAKtB,eAAzC;AACAwB,MAAAA,IAAI,GAAGA,IAAI,CAACD,OAAL,EAAP;AAEA,UAAME,cAAc,GAAG,EAAvB;AACA,UAAMC,iBAAiB,GAAG,EAA1B;AACA,UAAIC,iBAAiB,GAAG,IAAxB;;AAEA,WAAK,IAAIC,CAAC,GAAGjB,UAAU,CAACkB,MAAX,GAAoB,CAAjC,EAAoCD,CAAC,IAAI,CAAzC,EAA4CA,CAAC,IAAI,CAAjD,EAAoD;AAClD,YAAME,CAAC,GAAGnB,UAAU,CAACiB,CAAD,CAApB;AACA,YAAMG,CAAC,GAAG,IAAIX,IAAJ,CAASU,CAAC,CAACE,IAAX,EAAiBT,OAAjB,EAAV,CAFkD,CAIlD;;AACA,YAAIQ,CAAC,GAAGP,IAAJ,IAAYO,CAAC,GAAGZ,MAApB,EAA4B;AAC1B;AACA;AACA,cAAIW,CAAC,CAACG,KAAF,KAAY,UAAhB,EAA4B;AAC1B,gBAAIP,iBAAiB,CAACQ,OAAlB,CAA0BJ,CAAC,CAACK,QAA5B,MAA0C,CAAC,CAA/C,EAAkD;AAChDT,cAAAA,iBAAiB,CAACU,IAAlB,CAAuBN,CAAC,CAACK,QAAzB;AACD,aAFD,MAEO;AACLL,cAAAA,CAAC,CAACG,KAAF,GAAU,QAAV;AACD;AACF,WATyB,CAW1B;AACA;;;AACA,cACEN,iBAAiB,IACjBG,CAAC,CAACO,EAAF,CAAK,CAAL,MAAYV,iBAAiB,CAACU,EAAlB,CAAqB,CAArB,CADZ,IAEAC,IAAI,CAACC,GAAL,CAASR,CAAC,GAAGJ,iBAAiB,CAACK,IAA/B,IAAuC,IAFvC,IAGAF,CAAC,CAACU,IAAF,CAAOC,IAAP,KAAgBd,iBAAiB,CAACa,IAAlB,CAAuBC,IAJzC,EAKE;AACAX,YAAAA,CAAC,CAACG,KAAF,GAAU,QAAV;AACD;;AAED,cAAI,qCAAqCS,IAArC,CAA0CZ,CAAC,CAACG,KAA5C,CAAJ,EAAwD;AACtDH,YAAAA,CAAC,CAACa,SAAF,GAAc,IAAd;AACD;;AAEDhB,UAAAA,iBAAiB,GAAGG,CAApB;AACAH,UAAAA,iBAAiB,CAACK,IAAlB,GAAyBD,CAAzB;AACAN,UAAAA,cAAc,CAACmB,OAAf,CAAuBd,CAAvB;AACD;AACF;;AAED,aAAOL,cAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,6BAAoBoB,SAApB,EAAwE;AAAA;;AAAA,UAAzCnC,oBAAyC,uEAAlB,KAAkB;AAAA,UAAXoC,SAAW;AACtEC,MAAAA,MAAM,CAACC,YAAP,CAAoB,KAAKjD,sBAAzB;AACA,WAAKkD,qBAAL;AACA,WAAKnD,oBAAL,GAA4B+C,SAA5B;AACA,UAAM3C,OAAO,GAAG2C,SAAS,uBAAgBA,SAAhB,IAA8B,IAAvD;AACA,UAAMK,eAAe,GAAG,EAAxB;AACA,WAAK5C,SAAL,CACEJ,OADF,EAEE,UAACiD,IAAD,EAAU;AACR,YAAIA,IAAI,CAACC,MAAL,KAAgBlD,OAApB,EAA6B;AAC3B,cAAMmD,OAAO,GAAGF,IAAI,CAACE,OAAL,IAAgB,EAAhC;AACA,cAAMC,KAAK,GAAG,IAAIlC,IAAJ,CAASiC,OAAO,CAACE,SAAjB,EAA4BhC,OAA5B,KAAwCH,IAAI,CAACoC,GAAL,EAAtD;AACAH,UAAAA,OAAO,CAACI,QAAR,GAAmBH,KAAnB;AACAJ,UAAAA,eAAe,CAACG,OAAO,CAACK,OAAT,CAAf,GAAmCL,OAAnC;AAEAN,UAAAA,MAAM,CAACC,YAAP,CAAoB,KAAI,CAACjD,sBAAzB;AACA,UAAA,KAAI,CAACA,sBAAL,GAA8BgD,MAAM,CAACY,UAAP,CAAkB,YAAM;AACpD,gBAAMhD,UAAU,GAAG,KAAI,CAACiD,gBAAL,CACjBV,eADiB,EAEjBxC,oBAFiB,CAAnB;;AAIAoC,YAAAA,SAAS,CAACnC,UAAD,CAAT;AACD,WAN6B,EAM3B,GAN2B,CAA9B;AAOD;AACF,OAlBH,EAmBE,YAAM;AACJmC,QAAAA,SAAS,CAAC,EAAD,CAAT;AACD,OArBH;AAuBD;AAED;AACF;AACA;;;;WACE,iCAAwB;AACtB,UAAI,KAAKhD,oBAAT,EAA+B;AAC7B,aAAKU,WAAL,qBAA8B,KAAKV,oBAAnC;AACA,aAAKA,oBAAL,GAA4B,IAA5B;AACD;AACF;AAED;AACF;AACA;AACA;AACA;;;;WACE,8BAAqBgD,SAArB,EAAgC;AAC9B,WAAKxC,SAAL,CAAe,YAAf,EAA6B,UAAC6C,IAAD,EAAU;AACrCL,QAAAA,SAAS,CAACK,IAAI,CAACE,OAAN,CAAT;AACD,OAFD;AAGD;AAED;AACF;AACA;;;;WACE,kCAAyB;AACvB,WAAK7C,WAAL,CAAiB,YAAjB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,oBAAWqD,GAAX,EAAgBC,IAAhB,EAAsB;AAAA;;AACpB,UAAMC,MAAM,GAAG;AACb7D,QAAAA,OAAO,mBAAYnB,aAAa,CAAC+E,IAAD,EAAO5E,WAAP,CAAzB,CADM;AAEb8E,QAAAA,IAAI,EAAEH;AAFO,OAAf;AAKA,aAAO,IAAII,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtC,QAAA,MAAI,CAACxE,IAAL,CAAUyE,GAAV,CAAcL,MAAd,EAAsB,UAACZ,IAAD,EAAU;AAC9B,cAAIA,IAAI,CAACE,OAAT,EAAkB;AAChBa,YAAAA,OAAO,CAACf,IAAI,CAACE,OAAN,CAAP;AACD,WAFD,MAEO;AACLc,YAAAA,MAAM;AACP;AACF,SAND;AAOD,OARM,CAAP;AASD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,qBAAYL,IAAZ,EAAkBO,IAAlB,EAAwB;AAAA;;AACtB,UAAMC,QAAQ,GAAG,EAAjB;;AACA,UAAID,IAAJ,EAAU;AACR,aAAK1E,IAAL,CAAU4E,OAAV,CAAkBF,IAAlB;AACD;;AACD,UAAMN,MAAM,GAAG;AACb7D,QAAAA,OAAO,mBAAYnB,aAAa,CAAC+E,IAAD,EAAO5E,WAAP,CAAzB;AADM,OAAf;AAGA6D,MAAAA,MAAM,CAACC,YAAP,CAAoB,KAAKwB,oBAAzB;AACA,aAAO,IAAIP,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtC,QAAA,MAAI,CAACxE,IAAL,CAAUyE,GAAV,CAAcL,MAAd,EAAsB,UAACZ,IAAD,EAAU;AAC9B,cAAIA,IAAI,CAACE,OAAT,EAAkB;AAChBiB,YAAAA,QAAQ,CAAClC,IAAT,CAAce,IAAI,CAACE,OAAnB;AACAN,YAAAA,MAAM,CAACC,YAAP,CAAoB,MAAI,CAACwB,oBAAzB;AACA;;AACA,YAAA,MAAI,CAACA,oBAAL,GAA4BzB,MAAM,CAACY,UAAP,CAAkB,YAAM;AAClDO,cAAAA,OAAO,CAACI,QAAD,CAAP;AACD,aAF2B,EAEzB,EAFyB,CAA5B;AAGD,WAPD,MAOO;AACLH,YAAAA,MAAM,CAAChB,IAAI,CAACE,OAAN,CAAN;AACD;AACF,SAXD;AAYD,OAbM,CAAP;AAcD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,2BAAkBS,IAAlB,EAAwBO,IAAxB,EAA8BvB,SAA9B,EAAyC;AACvC,WAAK2B,mBAAL;;AACA,UAAIJ,IAAJ,EAAU;AACR,aAAK1E,IAAL,CAAU4E,OAAV,CAAkBF,IAAlB;AACD;;AACD,WAAK/D,SAAL,kBAAyBvB,aAAa,CAAC+E,IAAD,EAAO5E,WAAP,CAAtC,GAA6D,UAACiE,IAAD,EAAU;AACrE,YAAIA,IAAI,CAACE,OAAT,EAAkB;AAChBP,UAAAA,SAAS,CAACK,IAAI,CAACE,OAAN,CAAT;AACD;AACF,OAJD;AAKD;AAED;AACF;AACA;;;;WACE,+BAAsB;AACpBN,MAAAA,MAAM,CAACC,YAAP,CAAoB,KAAKwB,oBAAzB;AACA,WAAKhE,WAAL,CAAiB,SAAjB;AACD;AAED;AACF;AACA;AACA;AACA;;;;WACE,6BAAoBsC,SAApB,EAA+B;AAAA;;AAC7B,WAAKxC,SAAL,CAAe,aAAf,EAA8B,UAAC6C,IAAD,EAAU;AACtC,YAAMuB,SAAS,GAAGvB,IAAI,CAACE,OAAvB;;AAEA,YAAIqB,SAAJ,EAAe;AACb,cAAQC,GAAR,GAAgBD,SAAS,CAACE,UAA1B,CAAQD,GAAR;;AAEA,cAAID,SAAS,CAACG,IAAV,KAAmB,SAAvB,EAAkC;AAChC,YAAA,MAAI,CAAC5E,UAAL,CAAgB0E,GAAhB,IAAuBD,SAAvB;AACD,WAFD,MAEO;AACL,mBAAO,MAAI,CAACzE,UAAL,CAAgB0E,GAAhB,CAAP;AACD;;AAED7B,UAAAA,SAAS,CACPlC,MAAM,CAACC,IAAP,CAAY,MAAI,CAACZ,UAAjB,EAA6Ba,GAA7B,CAAiC,UAACgE,GAAD;AAAA,mBAAS,MAAI,CAAC7E,UAAL,CAAgB6E,GAAhB,CAAT;AAAA,WAAjC,CADO,CAAT;AAGD;AACF,OAhBD;AAiBD;AAED;AACF;AACA;;;;WACE,iCAAwB;AACtB,WAAKtE,WAAL,CAAiB,aAAjB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,6BAAoBsD,IAApB,EAA0BhB,SAA1B,EAAqC;AACnC,WAAKiC,qBAAL;AACA,WAAKzE,SAAL,qBAA4BvB,aAAa,CAAC+E,IAAD,EAAO5E,WAAP,CAAzC,GAAgE4D,SAAhE;AACD;AAED;AACF;AACA;;;;WACE,iCAAwB;AACtB,WAAKtC,WAAL;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,kCAAyBsD,IAAzB,EAA+BhB,SAA/B,EAA0C;AACxC,WAAKkC,0BAAL;AACA,WAAK1E,SAAL,2BACqBvB,aAAa,CAAC+E,IAAD,EAAO5E,WAAP,CADlC,GAEE4D,SAFF;AAID;AAED;AACF;AACA;;;;WACE,sCAA6B;AAC3B,WAAKtC,WAAL,CAAiB,kBAAjB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,2BAAkByE,EAAlB,EAAsBnB,IAAtB,EAA4B;AAAA;;AAC1B,UAAMC,MAAM,GAAG;AACb7D,QAAAA,OAAO,2BAAoBnB,aAAa,CAAC+E,IAAD,EAAO5E,WAAP,CAAjC,cAAwD+F,EAAxD;AADM,OAAf;AAIA,aAAO,IAAIhB,OAAJ,CAAY,UAACC,OAAD,EAAa;AAC9B,QAAA,MAAI,CAACvE,IAAL,CAAUyE,GAAV,CAAcL,MAAd,EAAsB,UAACZ,IAAD,EAAU;AAC9B,cAAIA,IAAI,CAACE,OAAT,EAAkB;AAChBa,YAAAA,OAAO,CAACf,IAAI,CAACE,OAAN,CAAP;AACD;AACF,SAJD;AAKD,OANM,CAAP;AAOD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,6BAAoB6B,GAApB,EAAyBpB,IAAzB,EAA+B;AAAA;;AAC7B,UAAMqB,QAAQ,GAAGD,GAAG,CAACpE,GAAJ,CAAQ,UAACmE,EAAD,EAAQ;AAC/B,eAAO,MAAI,CAACG,iBAAL,CAAuBH,EAAvB,EAA2BnB,IAA3B,CAAP;AACD,OAFgB,CAAjB;AAGA,aAAOG,OAAO,CAACoB,GAAR,CAAYF,QAAZ,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,iCAAwBF,EAAxB,EAA4BnB,IAA5B,EAAkC;AAChC;AACA,WAAKwB,yBAAL,CAA+BL,EAA/B;AACA,WAAK3E,SAAL,0BACoBvB,aAAa,CAAC+E,IAAD,EAAO5E,WAAP,CADjC,cACwD+F,EADxD,GAEE,UAAC9B,IAAD,EAAU;AACR;AACAoC,QAAAA,OAAO,CAACC,GAAR,CAAY,2BAAZ,EAAyCrC,IAAzC;AACD,OALH,EAME,UAACsC,GAAD,EAAS;AACP;AACAF,QAAAA,OAAO,CAACC,GAAR,CAAY,iCAAZ,EAA+CC,GAA/C;AACD,OATH;AAWD;AAED;AACF;AACA;AACA;AACA;;;;WACE,mCAA0BR,EAA1B,EAA8B;AAC5B,WAAKzE,WAAL,CAAiB,iBAAjB,aAAwCyE,EAAxC;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,yBAAgBA,EAAhB,EAAoBnB,IAApB,EAA0B;AAAA;;AACxB,UAAMC,MAAM,GAAG;AACb7D,QAAAA,OAAO,wBAAiBnB,aAAa,CAAC+E,IAAD,EAAO5E,WAAP,CAA9B,cAAqD+F,EAArD;AADM,OAAf;AAGA,aAAO,IAAIhB,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtC,QAAA,MAAI,CAACxE,IAAL,CAAUyE,GAAV,CACEL,MADF,EAEE,UAACZ,IAAD,EAAU;AACR;AACAe,UAAAA,OAAO,CAAClF,aAAa,CAACmE,IAAI,CAACE,OAAL,IAAgBF,IAAI,CAACE,OAAL,CAAa,CAAb,CAAjB,CAAd,CAAP;AACD,SALH,EAME,UAACoC,GAAD,EAAS;AACPtB,UAAAA,MAAM,CAACsB,GAAD,CAAN;AACD,SARH;AAUD,OAXM,CAAP;AAYD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,0BAAiBP,GAAjB,EAAsBpB,IAAtB,EAA4B;AAAA;;AAC1B,UAAMqB,QAAQ,GAAGD,GAAG,CAACpE,GAAJ,CAAQ,UAACmE,EAAD,EAAQ;AAC/B,eAAO,MAAI,CAACS,eAAL,CAAqBT,EAArB,EAAyBnB,IAAzB,CAAP;AACD,OAFgB,CAAjB;AAGA,aAAOG,OAAO,CAACoB,GAAR,CAAYF,QAAZ,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,+BAAsBF,EAAtB,EAA0BnB,IAA1B,EAAgChB,SAAhC,EAA2C;AACzCC,MAAAA,MAAM,CAACC,YAAP,CAAoB,KAAK2C,2BAAzB;AACA,WAAKC,uBAAL,CAA6BX,EAA7B;AAEA,WAAK3E,SAAL,uBACiBvB,aAAa,CAAC+E,IAAD,EAAO5E,WAAP,CAD9B,cACqD+F,EADrD,GAEE,UAAC9B,IAAD,EAAU;AACR;AACAL,QAAAA,SAAS,CAAC9D,aAAa,CAACmE,IAAI,CAACE,OAAL,IAAgBF,IAAI,CAACE,OAAL,CAAa,CAAb,CAAjB,CAAd,CAAT;AACD,OALH,EAME,UAACoC,GAAD,EAAS;AACP;AACAF,QAAAA,OAAO,CAACC,GAAR,CAAY,8BAAZ,EAA4CC,GAA5C;AACD,OATH;AAWD;AAED;AACF;AACA;AACA;AACA;;;;WACE,iCAAwBR,EAAxB,EAA4B;AAC1B,WAAKzE,WAAL,4BAAqCyE,EAArC;AACD;AAED;AACF;AACA;AACA;;;;WACE,8BAAqBnC,SAArB,EAAgC;AAC9B,WAAK+C,sBAAL;AACA,WAAKvF,SAAL,CAAe,aAAf,EAA8BwC,SAA9B;AACD;AAED;AACF;AACA;;;;WACE,kCAAyB;AACvB,WAAKtC,WAAL,CAAiB,aAAjB;AACD;;;;;;AAEH,eAAelB,SAAf","sourcesContent":["import WebSocketConnector from './WebSocketConnector';\nimport {\n  getModeSuffix,\n  cleanStopTime,\n  compareDepartures,\n} from './TralisAPIUtils';\n\n/**\n * Enum for Tralis modes.\n * @readonly\n * @typedef {string} TralisMode\n * @property {string} RAW \"raw\"\n * @property {string} SCHEMATIC \"schematic\"\n * @property {string} TOPOGRAPHIC \"topographic\"\n * @enum {TralisMode}\n */\nexport const TralisModes = {\n  RAW: 'raw',\n  TOPOGRAPHIC: 'topographic',\n  SCHEMATIC: 'schematic',\n};\n\n/**\n * Access to Tralis service.\n *\n * @example\n * import { TralisAPI } from 'mobility-toolbox-js/api';\n *\n * const api = new TralisAPI({\n *   url: \"yourUrl\",\n *   apiKey: \"yourApiKey\"\n * });\n *\n * @example\n * import { TralisAPI } from 'mobility-toolbox-js/api';\n *\n * const api = new TralisAPI(\"yourUrl\");\n */\nclass TralisAPI {\n  /**\n   * Constructor\n   *\n   * @param {Object|string} options A string representing the url of the service or an object containing the url and the apiKey.\n   * @param {string} options.url Service url.\n   * @param {string} options.apiKey Access key for [geOps services](https://developer.geops.io/).\n   * @param {string} [options.projection='epsg:3857'] The epsg code of the projection for features.\n   */\n  constructor(options = {}) {\n    let wsUrl = null;\n    if (typeof options === 'string') {\n      wsUrl = options;\n    } else {\n      wsUrl = options.url;\n    }\n    if (options.apiKey) {\n      wsUrl = `${wsUrl}?key=${options.apiKey}`;\n    }\n    /** @ignore */\n    this.conn = new WebSocketConnector(wsUrl);\n    this.conn.setProjection(options.projection || 'epsg:3857');\n    /** @ignore */\n    this.subscribedStationUic = null;\n    /** @ignore */\n    this.departureUpdateTimeout = null;\n    /** @ignore */\n    this.maxDepartureAge = 30;\n    /** @ignore */\n    this.extraGeoms = {};\n  }\n\n  /**\n   * Subscribe to a channel.\n   *\n   * @param {string} channel Name of the websocket channel to subscribe.\n   * @param {function} onSuccess Callback when the subscription succeeds.\n   * @param {function} onError Callback when the subscription fails.\n   * @param {boolean} [quiet=false] If true avoid to store the subscription in the subscriptions list.\n   * @private\n   */\n  subscribe(channel, onSuccess, onError, quiet = false) {\n    this.conn.subscribe({ channel }, onSuccess, onError, quiet);\n  }\n\n  /**\n   * Unsubscribe to a channel.\n   *\n   * @param {string} channel Name of the websocket channel to unsubscribe.\n   * @param {string} [suffix=''] Suffix to add to the channel name.\n   * @private\n   */\n  unsubscribe(channel, suffix = '') {\n    this.conn.unsubscribe(\n      `${channel}${getModeSuffix(TralisModes.SCHEMATIC, TralisModes)}${suffix}`,\n    );\n    this.conn.unsubscribe(\n      `${channel}${getModeSuffix(\n        TralisModes.TOPOGRAPHIC,\n        TralisModes,\n      )}${suffix}`,\n    );\n  }\n\n  /**\n   * Filter departures and return an array.\n   *\n   * @param {Object} depObject The object containing departures by id.\n   * @param {boolean} [sortByMinArrivalTime=false] If true sort departures by arrival time.\n   * @returns {Array<departure>} Return departures array.\n   * @private\n   */\n  filterDepartures(depObject, sortByMinArrivalTime = false) {\n    const departures = Object.keys(depObject).map((k) => depObject[k]);\n    departures.sort((a, b) => compareDepartures(a, b, sortByMinArrivalTime));\n\n    let future = new Date();\n    future.setMinutes(future.getMinutes() + this.maxDepartureAge);\n    future = future.getTime();\n\n    let past = new Date();\n    past.setMinutes(past.getMinutes() - this.maxDepartureAge);\n    past = past.getTime();\n\n    const departureArray = [];\n    const platformsBoarding = [];\n    let previousDeparture = null;\n\n    for (let i = departures.length - 1; i >= 0; i -= 1) {\n      const d = departures[i];\n      const t = new Date(d.time).getTime();\n\n      // Only show departures within the next 30 minutes\n      if (t > past && t < future) {\n        // If 2 trains are boarding at the same platform,\n        // remove the older one.\n        if (d.state === 'BOARDING') {\n          if (platformsBoarding.indexOf(d.platform) === -1) {\n            platformsBoarding.push(d.platform);\n          } else {\n            d.state = 'HIDDEN';\n          }\n        }\n\n        // If two trains with the same line number and destinatin\n        // and a departure difference < 1 minute, hide the second one.\n        if (\n          previousDeparture &&\n          d.to[0] === previousDeparture.to[0] &&\n          Math.abs(t - previousDeparture.time) < 1000 &&\n          d.line.name === previousDeparture.line.name\n        ) {\n          d.state = 'HIDDEN';\n        }\n\n        if (/(STOP_CANCELLED|JOURNEY_CANCELLED)/.test(d.state)) {\n          d.cancelled = true;\n        }\n\n        previousDeparture = d;\n        previousDeparture.time = t;\n        departureArray.unshift(d);\n      }\n    }\n\n    return departureArray;\n  }\n\n  /**\n   * Subscribe to departures channel of a given station.\n   *\n   * @param {number} stationId UIC of the station.\n   * @param {Boolean} sortByMinArrivalTime Sort by minimum arrival time\n   * @param {function(departures:Departure[])} onMessage Function called on each message of the channel.\n   */\n  subscribeDepartures(stationId, sortByMinArrivalTime = false, onMessage) {\n    window.clearTimeout(this.departureUpdateTimeout);\n    this.unsubscribeDepartures();\n    this.subscribedStationUic = stationId;\n    const channel = stationId ? `timetable_${stationId}` : null;\n    const departureObject = {};\n    this.subscribe(\n      channel,\n      (data) => {\n        if (data.source === channel) {\n          const content = data.content || {};\n          const tDiff = new Date(content.timestamp).getTime() - Date.now();\n          content.timediff = tDiff;\n          departureObject[content.call_id] = content;\n\n          window.clearTimeout(this.departureUpdateTimeout);\n          this.departureUpdateTimeout = window.setTimeout(() => {\n            const departures = this.filterDepartures(\n              departureObject,\n              sortByMinArrivalTime,\n            );\n            onMessage(departures);\n          }, 100);\n        }\n      },\n      () => {\n        onMessage([]);\n      },\n    );\n  }\n\n  /**\n   * Unsubscribe from current departures channel.\n   */\n  unsubscribeDepartures() {\n    if (this.subscribedStationUic) {\n      this.unsubscribe(`timetable_${this.subscribedStationUic}`);\n      this.subscribedStationUic = null;\n    }\n  }\n\n  /**\n   * Subscribe to the disruptions channel.\n   *\n   * @param {function} onMessage Function called on each message of the channel.\n   */\n  subscribeDisruptions(onMessage) {\n    this.subscribe('newsticker', (data) => {\n      onMessage(data.content);\n    });\n  }\n\n  /**\n   * Unsubscribe disruptions.\n   */\n  unsubscribeDisruptions() {\n    this.unsubscribe('newsticker');\n  }\n\n  /**\n   * Return a station with a given uic number and a mode.\n   *\n   * @param {number} uic UIC of the station.\n   * @param {TralisMode} mode Tralis mode.\n   * @returns {Promise<Station>} A station.\n   */\n  getStation(uic, mode) {\n    const params = {\n      channel: `station${getModeSuffix(mode, TralisModes)}`,\n      args: uic,\n    };\n\n    return new Promise((resolve, reject) => {\n      this.conn.get(params, (data) => {\n        if (data.content) {\n          resolve(data.content);\n        } else {\n          reject();\n        }\n      });\n    });\n  }\n\n  /**\n   * Update the model's station list for a given mode and a bbox.\n   *\n   * @param {TralisMode} mode Tralis mode.\n   * @param {number[4]} bbox The extent where to request.\n   * @returns {Promise<Station[]>} An array of stations.\n   */\n  getStations(mode, bbox) {\n    const stations = [];\n    if (bbox) {\n      this.conn.setBbox(bbox);\n    }\n    const params = {\n      channel: `station${getModeSuffix(mode, TralisModes)}`,\n    };\n    window.clearTimeout(this.stationUpdateTimeout);\n    return new Promise((resolve, reject) => {\n      this.conn.get(params, (data) => {\n        if (data.content) {\n          stations.push(data.content);\n          window.clearTimeout(this.stationUpdateTimeout);\n          /** @ignore */\n          this.stationUpdateTimeout = window.setTimeout(() => {\n            resolve(stations);\n          }, 50);\n        } else {\n          reject(data.content);\n        }\n      });\n    });\n  }\n\n  /**\n   * Subscribe to stations channel.\n   * One message pro station.\n   *\n   * @param {TralisMode} mode Tralis mode.\n   * @param {number[4]} bbox The extent where to request.\n   * @param {function(station: Station)} onMessage Function called on each message of the channel.\n   */\n  subscribeStations(mode, bbox, onMessage) {\n    this.unsubscribeStations();\n    if (bbox) {\n      this.conn.setBbox(bbox);\n    }\n    this.subscribe(`station${getModeSuffix(mode, TralisModes)}`, (data) => {\n      if (data.content) {\n        onMessage(data.content);\n      }\n    });\n  }\n\n  /**\n   * Unsubscribe to stations channel.\n   */\n  unsubscribeStations() {\n    window.clearTimeout(this.stationUpdateTimeout);\n    this.unsubscribe('station');\n  }\n\n  /**\n   * Subscribe to extra_geoms channel.\n   *\n   * @param {function(extraGeoms: GeosJSONFeature[])} onMessage Function called on each message of the channel.\n   */\n  subscribeExtraGeoms(onMessage) {\n    this.subscribe('extra_geoms', (data) => {\n      const extraGeom = data.content;\n\n      if (extraGeom) {\n        const { ref } = extraGeom.properties;\n\n        if (extraGeom.type === 'Feature') {\n          this.extraGeoms[ref] = extraGeom;\n        } else {\n          delete this.extraGeoms[ref];\n        }\n\n        onMessage(\n          Object.keys(this.extraGeoms).map((key) => this.extraGeoms[key]),\n        );\n      }\n    });\n  }\n\n  /**\n   * Unsubscribe to extra_geoms channel.\n   */\n  unsubscribeExtraGeoms() {\n    this.unsubscribe('extra_geoms');\n  }\n\n  /**\n   * Subscribe to trajectory channel.\n   *\n   * @param {TralisMode} mode Tralis mode.\n   * @param {function(trajectory: TralisTrajectory)} onMessage Function called on each message of the channel.\n   */\n  subscribeTrajectory(mode, onMessage) {\n    this.unsubscribeTrajectory();\n    this.subscribe(`trajectory${getModeSuffix(mode, TralisModes)}`, onMessage);\n  }\n\n  /**\n   * Unsubscribe to trajectory channels.\n   */\n  unsubscribeTrajectory() {\n    this.unsubscribe(`trajectory`);\n  }\n\n  /**\n   * Subscribe to deleted_vhicles channel.\n   *\n   * @param {TralisMode} mode Tralis mode.\n   * @param {function(response: { content: Vehicle })} onMessage Function called on each message of the channel.\n   */\n  subscribeDeletedVehicles(mode, onMessage) {\n    this.unsubscribeDeletedVehicles();\n    this.subscribe(\n      `deleted_vehicles${getModeSuffix(mode, TralisModes)}`,\n      onMessage,\n    );\n  }\n\n  /**\n   * Unsubscribe to deleted_vhicles channels.\n   */\n  unsubscribeDeletedVehicles() {\n    this.unsubscribe('deleted_vehicles');\n  }\n\n  /**\n   * Get a full trajectory of a vehicule .\n   *\n   * @param {number} id A vehicle id.\n   * @param {TralisMode} mode Tralis mode.\n   * @returns {Promise<FullTrajectory>} Return a full trajectory.\n   */\n  getFullTrajectory(id, mode) {\n    const params = {\n      channel: `full_trajectory${getModeSuffix(mode, TralisModes)}_${id}`,\n    };\n\n    return new Promise((resolve) => {\n      this.conn.get(params, (data) => {\n        if (data.content) {\n          resolve(data.content);\n        }\n      });\n    });\n  }\n\n  /**\n   * Get full trajectories of a vehicules .\n   *\n   * @param {number[]} ids List of vehicles ids.\n   * @param {TralisMode} mode Tralis mode.\n   * @returns {Promise<FullTrajectory[]>} Return an array of full trajectories.\n   */\n  getFullTrajectories(ids, mode) {\n    const promises = ids.map((id) => {\n      return this.getFullTrajectory(id, mode);\n    });\n    return Promise.all(promises);\n  }\n\n  /**\n   * Subscribe to full_trajectory channel of a given vehicle.\n   *\n   * @param {number} id A vehicle id.\n   * @param {TralisMode} mode Tralis mode.\n   */\n  subscribeFullTrajectory(id, mode) {\n    // window.clearTimeout(this.fullTrajectoryUpdateTimeout);\n    this.unsubscribeFullTrajectory(id);\n    this.subscribe(\n      `full_trajectory${getModeSuffix(mode, TralisModes)}_${id}`,\n      (data) => {\n        // eslint-disable-next-line no-console\n        console.log('subscribe full_trajectory', data);\n      },\n      (err) => {\n        // eslint-disable-next-line no-console\n        console.log('subscribe full_trajectory error', err);\n      },\n    );\n  }\n\n  /**\n   * Unsubscribe from full_trajectory channel\n   *\n   * @param {number} id A vehicle id.\n   */\n  unsubscribeFullTrajectory(id) {\n    this.unsubscribe('full_trajectory', `_${id}`);\n  }\n\n  /**\n   * Get the list of stops for this vehicle.\n   *\n   * @param {number} id A vehicle id.\n   * @param {TralisMode} mode Tralis mode.\n   * @returns {Promise<StopSequence>} Returns a stop sequence object.\n   */\n  getStopSequence(id, mode) {\n    const params = {\n      channel: `stopsequence${getModeSuffix(mode, TralisModes)}_${id}`,\n    };\n    return new Promise((resolve, reject) => {\n      this.conn.get(\n        params,\n        (data) => {\n          // Remove the delay from arrivalTime nad departureTime\n          resolve(cleanStopTime(data.content && data.content[0]));\n        },\n        (err) => {\n          reject(err);\n        },\n      );\n    });\n  }\n\n  /**\n   * Get a list of stops for a list of vehicles.\n   *\n   * @param {number[]} ids List of vehicles ids.\n   * @param {TralisMode} mode Tralis mode.\n   * @returns {Promise<StopSequence[]>} Return an array of stop sequences.\n   */\n  getStopSequences(ids, mode) {\n    const promises = ids.map((id) => {\n      return this.getStopSequence(id, mode);\n    });\n    return Promise.all(promises);\n  }\n\n  /**\n   * Subscribe to stopsequence channel of a given vehicle.\n   *\n   * @param {number} id A vehicle id.\n   * @param {TralisMode} mode Tralis mode.\n   * @param {function(stopSequence: StopSequence)} onMessage Function called on each message of the channel.\n   */\n  subscribeStopSequence(id, mode, onMessage) {\n    window.clearTimeout(this.fullTrajectoryUpdateTimeout);\n    this.unsubscribeStopSequence(id);\n\n    this.subscribe(\n      `stopsequence${getModeSuffix(mode, TralisModes)}_${id}`,\n      (data) => {\n        // Remove the delay from arrivalTime nad departureTime\n        onMessage(cleanStopTime(data.content && data.content[0]));\n      },\n      (err) => {\n        // eslint-disable-next-line no-console\n        console.log('subscribe stopsequence error', err);\n      },\n    );\n  }\n\n  /**\n   * Unsubscribe from stopsequence channel\n   *\n   * @param {number} id A vehicle id.\n   */\n  unsubscribeStopSequence(id) {\n    this.unsubscribe(`stopsequence`, `_${id}`);\n  }\n\n  /**\n   * Subscribe to healthcheck channel.\n   * @param {function} onMessage Callback when the subscribe to healthcheck channel succeeds.\n   */\n  subscribeHealthCheck(onMessage) {\n    this.unsubscribeHealthCheck();\n    this.subscribe('healthcheck', onMessage);\n  }\n\n  /**\n   * Unsubscribe to healthcheck channel.\n   */\n  unsubscribeHealthCheck() {\n    this.unsubscribe('healthcheck');\n  }\n}\nexport default TralisAPI;\n"]},"metadata":{},"sourceType":"module"}