{"ast":null,"code":"import _slicedToArray from \"/home/daniel/gitRepos/danji90.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectSpread from \"/home/daniel/gitRepos/danji90.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _classCallCheck from \"/home/daniel/gitRepos/danji90.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/daniel/gitRepos/danji90.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"/home/daniel/gitRepos/danji90.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/home/daniel/gitRepos/danji90.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/daniel/gitRepos/danji90.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/daniel/gitRepos/danji90.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Layer as OLLayer, Group } from 'ol/layer';\nimport { unByKey } from 'ol/Observable';\nimport Source from 'ol/source/Source';\nimport mixin from '../../common/mixins/TrackerLayerMixin';\nimport Layer from './Layer';\n/**\n * Responsible for loading tracker data.\n *\n * @extends {Layer}\n * @implements {TrackerLayerInterface}\n */\n\nvar TrackerLayer = /*#__PURE__*/function (_mixin) {\n  _inherits(TrackerLayer, _mixin);\n\n  var _super = _createSuper(TrackerLayer);\n\n  /**\n   * Constructor.\n   *\n   * @param {Object} options\n   * @param {boolean} options.useDelayStyle Set the delay style.\n   * @private\n   */\n  function TrackerLayer() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, TrackerLayer);\n\n    // We use a group to be able to add custom vector layer in extended class.\n    // For example TrajservLayer use a vectorLayer to display the complete trajectory.\n    _this = _super.call(this, _objectSpread({}, options));\n    _this.olLayer = options.olLayer || new Group({\n      layers: [new OLLayer({\n        source: new Source({}),\n        render: function render(frameState) {\n          if (_this.tracker && _this.tracker.canvas) {\n            _this.tracker.renderTrajectories(_this.currTime, frameState.size, frameState.viewState.resolution);\n\n            return _this.tracker.canvas;\n          }\n\n          return null;\n        }\n      })]\n    });\n    /**\n     * Array of ol events key, returned by on() or once().\n     * @type {Array<ol/events~EventsKey>}\n     * @private\n     */\n\n    _this.olEventsKeys = []; // Be careful to not override this value in child classe.\n\n    return _this;\n  }\n  /**\n   * Initialize the layer and listen to feature clicks.\n   * @param {ol/Map~Map} map A OpenLayers map.\n   * @private\n   */\n\n\n  _createClass(TrackerLayer, [{\n    key: \"init\",\n    value: function init(map) {\n      if (!map) {\n        return;\n      }\n\n      _get(_getPrototypeOf(TrackerLayer.prototype), \"init\", this).call(this, map, {\n        getPixelFromCoordinate: map.getPixelFromCoordinate.bind(map)\n      });\n    }\n    /**\n     * Set the current time, it triggers a rendering of the trajectories.\n     * @param {dateString | value} time\n     */\n\n  }, {\n    key: \"setCurrTime\",\n    value: function setCurrTime(time) {\n      var view = this.map.getView();\n\n      _get(_getPrototypeOf(TrackerLayer.prototype), \"setCurrTime\", this).call(this, time, this.map.getSize(), view.getResolution());\n    }\n    /**\n     * Trackerlayer is started.\n     * @private\n     */\n\n  }, {\n    key: \"start\",\n    value: function start() {\n      var _this2 = this;\n\n      _get(_getPrototypeOf(TrackerLayer.prototype), \"start\", this).call(this, this.map.getSize(), this.currentZoom, this.map.getView().getResolution());\n\n      this.olEventsKeys = [this.map.on('moveend', function () {\n        var z = _this2.map.getView().getZoom();\n\n        if (z !== _this2.currentZoom) {\n          /**\n           * Current value of the zoom.\n           * @type {number}\n           */\n          _this2.currentZoom = z;\n\n          _this2.startUpdateTime(z);\n        }\n      }), this.map.on('pointermove', function (evt) {\n        if (_this2.map.getView().getInteracting() || !_this2.isHoverActive) {\n          return;\n        }\n\n        var _this2$getVehiclesAtC = _this2.getVehiclesAtCoordinate(evt.coordinate),\n            _this2$getVehiclesAtC2 = _slicedToArray(_this2$getVehiclesAtC, 1),\n            vehicle = _this2$getVehiclesAtC2[0];\n\n        _this2.map.getTargetElement().style.cursor = vehicle ? 'pointer' : 'auto';\n\n        _this2.tracker.setHoverVehicleId(vehicle && vehicle.id);\n      })];\n    }\n    /**\n     * Stop current layer.\n     * @private\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      _get(_getPrototypeOf(TrackerLayer.prototype), \"stop\", this).call(this);\n\n      unByKey(this.olEventsKeys);\n      this.olEventsKeys = [];\n    }\n    /**\n     * Returns the vehicle which are at the given coordinates.\n     * Returns null when no vehicle is located at the given coordinates.\n     * @param {ol/coordinate~Coordinate} coordinate\n     * @returns {ol/Feature~Feature} Vehicle feature.\n     * @private\n     */\n\n  }, {\n    key: \"getVehiclesAtCoordinate\",\n    value: function getVehiclesAtCoordinate(coordinate) {\n      var resolution = this.map.getView().getResolution();\n      return _get(_getPrototypeOf(TrackerLayer.prototype), \"getVehiclesAtCoordinate\", this).call(this, coordinate, resolution);\n    }\n    /**\n     * Create a copy of the TrackerLayer.\n     * @param {Object} newOptions Options to override\n     * @returns {TrackerLayer} A TrackerLayer\n     */\n\n  }, {\n    key: \"clone\",\n    value: function clone(newOptions) {\n      return new TrackerLayer(_objectSpread(_objectSpread({}, this.options), newOptions));\n    }\n  }]);\n\n  return TrackerLayer;\n}(mixin(Layer));\n\nexport default TrackerLayer;","map":{"version":3,"sources":["/home/daniel/gitRepos/danji90.github.io/node_modules/mobility-toolbox-js/ol/layers/TrackerLayer.js"],"names":["Layer","OLLayer","Group","unByKey","Source","mixin","TrackerLayer","options","olLayer","layers","source","render","frameState","tracker","canvas","renderTrajectories","currTime","size","viewState","resolution","olEventsKeys","map","getPixelFromCoordinate","bind","time","view","getView","getSize","getResolution","currentZoom","on","z","getZoom","startUpdateTime","evt","getInteracting","isHoverActive","getVehiclesAtCoordinate","coordinate","vehicle","getTargetElement","style","cursor","setHoverVehicleId","id","newOptions"],"mappings":"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","sourcesContent":["import { Layer as OLLayer, Group } from 'ol/layer';\nimport { unByKey } from 'ol/Observable';\nimport Source from 'ol/source/Source';\nimport mixin from '../../common/mixins/TrackerLayerMixin';\nimport Layer from './Layer';\n\n/**\n * Responsible for loading tracker data.\n *\n * @extends {Layer}\n * @implements {TrackerLayerInterface}\n */\nclass TrackerLayer extends mixin(Layer) {\n  /**\n   * Constructor.\n   *\n   * @param {Object} options\n   * @param {boolean} options.useDelayStyle Set the delay style.\n   * @private\n   */\n  constructor(options = {}) {\n    // We use a group to be able to add custom vector layer in extended class.\n    // For example TrajservLayer use a vectorLayer to display the complete trajectory.\n    super({\n      ...options,\n    });\n\n    this.olLayer =\n      options.olLayer ||\n      new Group({\n        layers: [\n          new OLLayer({\n            source: new Source({}),\n            render: (frameState) => {\n              if (this.tracker && this.tracker.canvas) {\n                this.tracker.renderTrajectories(\n                  this.currTime,\n                  frameState.size,\n                  frameState.viewState.resolution,\n                );\n                return this.tracker.canvas;\n              }\n              return null;\n            },\n          }),\n        ],\n      });\n\n    /**\n     * Array of ol events key, returned by on() or once().\n     * @type {Array<ol/events~EventsKey>}\n     * @private\n     */\n    this.olEventsKeys = []; // Be careful to not override this value in child classe.\n  }\n\n  /**\n   * Initialize the layer and listen to feature clicks.\n   * @param {ol/Map~Map} map A OpenLayers map.\n   * @private\n   */\n  init(map) {\n    if (!map) {\n      return;\n    }\n\n    super.init(map, {\n      getPixelFromCoordinate: map.getPixelFromCoordinate.bind(map),\n    });\n  }\n\n  /**\n   * Set the current time, it triggers a rendering of the trajectories.\n   * @param {dateString | value} time\n   */\n  setCurrTime(time) {\n    const view = this.map.getView();\n    super.setCurrTime(time, this.map.getSize(), view.getResolution());\n  }\n\n  /**\n   * Trackerlayer is started.\n   * @private\n   */\n  start() {\n    super.start(\n      this.map.getSize(),\n      this.currentZoom,\n      this.map.getView().getResolution(),\n    );\n\n    this.olEventsKeys = [\n      this.map.on('moveend', () => {\n        const z = this.map.getView().getZoom();\n\n        if (z !== this.currentZoom) {\n          /**\n           * Current value of the zoom.\n           * @type {number}\n           */\n          this.currentZoom = z;\n          this.startUpdateTime(z);\n        }\n      }),\n      this.map.on('pointermove', (evt) => {\n        if (this.map.getView().getInteracting() || !this.isHoverActive) {\n          return;\n        }\n        const [vehicle] = this.getVehiclesAtCoordinate(evt.coordinate);\n        this.map.getTargetElement().style.cursor = vehicle ? 'pointer' : 'auto';\n        this.tracker.setHoverVehicleId(vehicle && vehicle.id);\n      }),\n    ];\n  }\n\n  /**\n   * Stop current layer.\n   * @private\n   */\n  stop() {\n    super.stop();\n    unByKey(this.olEventsKeys);\n    this.olEventsKeys = [];\n  }\n\n  /**\n   * Returns the vehicle which are at the given coordinates.\n   * Returns null when no vehicle is located at the given coordinates.\n   * @param {ol/coordinate~Coordinate} coordinate\n   * @returns {ol/Feature~Feature} Vehicle feature.\n   * @private\n   */\n  getVehiclesAtCoordinate(coordinate) {\n    const resolution = this.map.getView().getResolution();\n    return super.getVehiclesAtCoordinate(coordinate, resolution);\n  }\n\n  /**\n   * Create a copy of the TrackerLayer.\n   * @param {Object} newOptions Options to override\n   * @returns {TrackerLayer} A TrackerLayer\n   */\n  clone(newOptions) {\n    return new TrackerLayer({ ...this.options, ...newOptions });\n  }\n}\n\nexport default TrackerLayer;\n"]},"metadata":{},"sourceType":"module"}