function objectWithoutProperties (obj, exclude) { var target = {}; for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k]; return target; }
import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';

import { MdClose } from 'react-icons/md';
import OLMap from 'ol/Map';
import Feature from 'ol/Feature';
import { getCenter } from 'ol/extent';
import { unByKey } from 'ol/Observable';

var propTypes = {
  /**
   * React Children.
   */
  children: PropTypes.node.isRequired,

  /**
   * An [ol/map](https://openlayers.org/en/latest/apidoc/module-ol_Map-Map.html).
   */
  map: PropTypes.instanceOf(OLMap).isRequired,

  /**
   * An [ol/Feature](https://openlayers.org/en/latest/apidoc/module-ol_Feature-Feature.html).
   */
  feature: PropTypes.instanceOf(Feature),

  /**
   * Popup title.
   */
  header: PropTypes.oneOfType([PropTypes.string, PropTypes.element]),

  /**
   * If true, the popup is panned in the map's viewport.
   */
  panIntoView: PropTypes.bool,

  /**
   * Custom BoundingClientRect to fit popup into.
   * Use if panIntoView is true. Default is the map's BoundingClientRect.
   */
  panRect: PropTypes.objectOf(PropTypes.number),

  /**
   * Coordinate position of the popup.
   */
  popupCoordinate: PropTypes.arrayOf(PropTypes.number),

  /**
   * Class name of the popup.
   */
  className: PropTypes.string,

  /**
   * Title HTML attributes.
   */
  titles: PropTypes.shape({
    closeButton: PropTypes.string,
  }),

  /**
   * Function triggered on close button click.
   */
  onCloseClick: PropTypes.func,

  /**
   * HTML tabIndex attribute.
   */
  tabIndex: PropTypes.string,

  /**
   * Render the header
   */
  renderHeader: PropTypes.func,

  /**
   * Render the close button
   */
  renderCloseButton: PropTypes.func,

  /**
   * Render the footer
   */
  renderFooter: PropTypes.func,
};

var defaultProps = {
  header: null,
  feature: null,
  panIntoView: false,
  panRect: null,
  popupCoordinate: null,
  className: 'rs-popup',
  tabIndex: '',
  titles: { closeButton: 'Close' },
  onCloseClick: function () {},
  renderHeader: null,
  renderCloseButton: null,
  renderFooter: function () { return null; },
};

/**
 * The Popup component renders a popup over an
 * [ol/Feature](https://openlayers.org/en/latest/apidoc/module-ol_Feature-Feature.html)
 * on click.
 */
var Popup = /*@__PURE__*/(function (PureComponent) {
  function Popup(props) {
    PureComponent.call(this, props);
    this.state = {
      popupElement: null,
      top: 0,
      left: 0,
    };
    this.postrenderKey = null;
  }

  if ( PureComponent ) Popup.__proto__ = PureComponent;
  Popup.prototype = Object.create( PureComponent && PureComponent.prototype );
  Popup.prototype.constructor = Popup;

  Popup.renderHeader = function renderHeader (props) {
    var header = props.header;
    var renderCloseButton = props.renderCloseButton;
    return (
      React.createElement( 'div', { className: "rs-popup-header" },
        header,
        (renderCloseButton || Popup.renderCloseButton)(props)
      )
    );
  };

  Popup.renderCloseButton = function renderCloseButton (ref) {
    var onCloseClick = ref.onCloseClick;
    var titles = ref.titles;

    return (
      React.createElement( 'div', {
        role: "button", tabIndex: 0, className: "rs-popup-close-bt", title: titles.closeButton, 'aria-label': titles.closeButton, onClick: function () { return onCloseClick(); }, onKeyPress: function (evt) { return evt.which === 13 && onCloseClick(); } },
        React.createElement( MdClose, { focusable: false })
      )
    );
  };

  Popup.prototype.componentDidMount = function componentDidMount () {
    var this$1 = this;

    var ref = this.props;
    var map = ref.map;
    this.updatePixelPosition();

    this.postrenderKey = map.on('postrender', function () {
      this$1.updatePixelPosition();
    });
  };

  Popup.prototype.componentDidUpdate = function componentDidUpdate (prevProps, prevState) {
    var ref = this.props;
    var feature = ref.feature;
    var panIntoView = ref.panIntoView;
    var popupCoordinate = ref.popupCoordinate;
    var ref$1 = this.state;
    var popupElement = ref$1.popupElement;
    if (
      feature !== prevProps.feature ||
      popupCoordinate !== prevProps.popupCoordinate
    ) {
      this.updatePixelPosition();
    }

    if (
      panIntoView &&
      popupElement &&
      popupElement !== prevState.popupElement
    ) {
      this.panIntoView();
    }
  };

  Popup.prototype.componentWillUnmount = function componentWillUnmount () {
    unByKey(this.postrenderKey);
  };

  Popup.prototype.panIntoView = function panIntoView () {
    var ref = this.props;
    var map = ref.map;
    var panRect = ref.panRect;
    var ref$1 = this.state;
    var popupElement = ref$1.popupElement;

    var mapRect = panRect || map.getTarget().getBoundingClientRect();
    var popupRect = popupElement.getBoundingClientRect();
    var ref$2 = map.getView().getCenter();
    var x = ref$2[0];
    var y = ref$2[1];
    var res = map.getView().getResolution();
    var newCenter = [x, y];

    if (mapRect.top > popupRect.top) {
      newCenter[1] = y + (mapRect.top - popupRect.top) * res;
    }

    if (mapRect.left > popupRect.left) {
      newCenter[0] = x - (mapRect.left - popupRect.left) * res;
    }

    if (mapRect.right < popupRect.right) {
      newCenter[0] = x + (popupRect.right - mapRect.right) * res;
    }

    if (mapRect.bottom < popupRect.bottom) {
      newCenter[1] = y - (popupRect.bottom - mapRect.bottom) * res;
    }

    if (newCenter[0] !== x || newCenter[1] !== y) {
      map.getView().animate({ center: newCenter, duration: 500 });
    }
  };

  Popup.prototype.updatePixelPosition = function updatePixelPosition () {
    var ref = this.props;
    var map = ref.map;
    var feature = ref.feature;
    var popupCoordinate = ref.popupCoordinate;
    var coord = popupCoordinate;

    if (feature && !coord) {
      coord = getCenter(feature.getGeometry().getExtent());
    }

    if (coord) {
      var pos = map.getPixelFromCoordinate(coord);

      if (pos && pos.length === 2) {
        this.setState({
          left: pos[0],
          top: pos[1],
        });
      }
    }
  };

  Popup.prototype.render = function render () {
    var this$1 = this;

    var ref = this.props;
    var feature = ref.feature;
    var popupCoordinate = ref.popupCoordinate;
    var children = ref.children;
    var header = ref.header;
    var titles = ref.titles;
    var tabIndex = ref.tabIndex;
    var renderHeader = ref.renderHeader;
    var renderFooter = ref.renderFooter;
    var rest = objectWithoutProperties( ref, ["feature", "popupCoordinate", "children", "header", "titles", "tabIndex", "renderHeader", "renderFooter"] );
    var other = rest;

    if (!feature && !popupCoordinate) {
      return null;
    }

    delete other.panIntoView;
    delete other.panRect;
    delete other.map;
    delete other.header;
    delete other.onCloseClick;
    delete other.renderCloseButton;

    var ref$1 = this.state;
    var top = ref$1.top;
    var left = ref$1.left;

    // force re-render if the feature or the coordinate changes.
    // this is needed to update the popupElement ref
    var key = feature ? feature.getId() : popupCoordinate.join();
    return (
      React.createElement( 'div', Object.assign({},
        { className: "rs-popup", style: {
          left: left,
          top: top,
        } }, other),
        React.createElement( 'div', {
          className: "rs-popup-container", tabIndex: tabIndex, key: key, ref: function (popupElement) {
            this$1.setState({ popupElement: popupElement });
          } },
          (renderHeader || Popup.renderHeader)(this.props),
          React.createElement( 'div', { className: "rs-popup-body" }, children),
          renderFooter(this.props)
        )
      )
    );
  };

  return Popup;
}(PureComponent));

Popup.propTypes = propTypes;
Popup.defaultProps = defaultProps;

export default Popup;

//# sourceMappingURL=Popup.js.map