import React, { Component } from 'react';
import PropTypes from 'prop-types';

var propTypes = {
  /**
   * Layers provider.
   */
  layerService: PropTypes.object,

  /**
   * CSS class to apply on the container.
   */
  className: PropTypes.string,

  /**
   * Padding left to apply on each level.
   */
  padding: PropTypes.number,

  /**
   * Determine if the item is hidden in the tree or not.
   *
   * @param {object} item The item to hide or not.
   *
   * @return {bool} true if the item is not displayed in the tree
   */
  isItemHidden: PropTypes.func,

  /**
   * Determine the className used by the div containing the parent and its children.
   */
  getParentClassName: PropTypes.func,

  /**
   * Custom function to render an item in the tree.
   *
   * @param {object} item The item to render.
   *
   * @return {node} A jsx node.
   */
  renderItem: PropTypes.func,

  /**
   * Custom function to render only the content of an item in the tree.
   *
   * @param {object} item The item to render.
   *
   * @return {node} A jsx node.
   */
  renderItemContent: PropTypes.func,

  /**
   * Custom function to render custom content before the list of children of an item.
   *
   * @param {object} item The item to render.
   *
   * @return {node} A jsx node.
   */
  renderBeforeItem: PropTypes.func,

  /**
   * Custom function to render custom content after the list of children of an item.
   *
   * @param {object} item The item to render.
   *
   * @return {node} A jsx node.
   */
  renderAfterItem: PropTypes.func,

  /**
   * Object holding title for the layer tree's buttons.
   */
  titles: PropTypes.shape({
    /**
     * aria-label on checkbox to show layer.
     */
    layerShow: PropTypes.string,
    /**
     * aria-label on checkbox to hide layer.
     */
    layerHide: PropTypes.string,
    /**
     * title on button to show sublayers.
     */
    subLayerShow: PropTypes.string,
    /**
     * title on button to show sublayers.
     */
    subLayerHide: PropTypes.string,
  }),

  /**
   * Translation function.
   * @param {function} Translation function returning the translated string.
   */
  t: PropTypes.func,
};

var defaultProps = {
  layerService: undefined,
  className: 'rs-layer-tree',
  padding: 30,
  isItemHidden: function () { return false; },
  getParentClassName: function () { return undefined; },
  renderItem: null,
  renderItemContent: null,
  renderBeforeItem: null,
  renderAfterItem: null,
  titles: {
    layerShow: 'Show layer',
    layerHide: 'Hide layer',
    subLayerShow: 'Show sublayer',
    subLayerHide: 'Hide sublayer',
  },
  t: function (s) { return s; },
};

/**
 * The LayerTree component renders an interface for toggling
 * [mobility-toolbox-js layers](https://mobility-toolbox-js.geops.io/api/identifiers%20html#ol-layers)
 * and their corresponding child layers.
 */

var LayerTree = /*@__PURE__*/(function (Component) {
  function LayerTree(props) {
    Component.call(this, props);
    var ref = this.props;
    var layerService = ref.layerService;
    var isItemHidden = ref.isItemHidden;
    var initialExpandedLayerNames =
      layerService && layerService.getLayers()
        ? this.getExpandedLayers(
            layerService
              .getLayers()
              .filter(
                function (l) { return !isItemHidden(l) &&
                  l.getVisibleChildren().filter(function (c) { return !isItemHidden(c); }).length; }
              )
          )
        : [];

    this.state = {
      layers: layerService ? layerService.getLayers() : [],
      expandedLayerNames: initialExpandedLayerNames,
    };
    this.updateLayers = this.updateLayers.bind(this);
    this.olKeys = [];
  }

  if ( Component ) LayerTree.__proto__ = Component;
  LayerTree.prototype = Object.create( Component && Component.prototype );
  LayerTree.prototype.constructor = LayerTree;

  LayerTree.prototype.componentDidMount = function componentDidMount () {
    this.updateLayerService();
  };

  LayerTree.prototype.componentDidUpdate = function componentDidUpdate (prevProps) {
    var ref = this.props;
    var layerService = ref.layerService;

    if (layerService !== prevProps.layerService) {
      this.updateLayerService();
    }
  };

  LayerTree.prototype.componentWillUnmount = function componentWillUnmount () {
    var ref = this.props;
    var layerService = ref.layerService;
    layerService.un('change:visible', this.updateLayers);
  };

  LayerTree.prototype.onInputClick = function onInputClick (layer, toggle) {
    if ( toggle === void 0 ) toggle = false;

    if (toggle) {
      this.onToggle(layer);
    } else {
      layer.setVisible(!layer.visible);
    }
  };

  LayerTree.prototype.onToggle = function onToggle (layer) {
    var ref = this.state;
    var expandedLayerNames = ref.expandedLayerNames;
    var pos = expandedLayerNames.indexOf(layer);
    if (pos > -1) {
      expandedLayerNames.splice(pos, 1);
    } else {
      expandedLayerNames.push.apply(expandedLayerNames, this.getExpandedLayers([layer]));
    }

    this.setState({ expandedLayerNames: expandedLayerNames });
  };

  /**
   * Get the always expanded ancestors (isAlwaysExpanded=true) of the given layers
   * together with the (given) initially expanded layers
   *
   * @param  {Layer} layers Initially expanded layers
   * @return {Array.<Layer>} Initially expanded layers and all its always expanded ancestors
   */
  LayerTree.prototype.getExpandedLayers = function getExpandedLayers (layers) {
    var ref = this.props;
    var isItemHidden = ref.isItemHidden;
    var children = layers.flatMap(function (l) { return l.children.filter(function (c) { return !isItemHidden(c) && c.get('isAlwaysExpanded'); }); }
    );

    if (!children.length) {
      return layers;
    }
    return layers.concat( [this.getExpandedLayers(children)]).flat();
  };

  LayerTree.prototype.updateLayerService = function updateLayerService () {
    var ref = this.props;
    var layerService = ref.layerService;
    if (layerService) {
      layerService.un('change:visible', this.updateLayers);
      this.updateLayers();
      layerService.on('change:visible', this.updateLayers);
    }
  };

  LayerTree.prototype.updateLayers = function updateLayers () {
    var ref = this.props;
    var layerService = ref.layerService;
    this.setState({
      layers: layerService.getLayers(),
    });
  };

  LayerTree.prototype.renderInput = function renderInput (layer) {
    var this$1 = this;

    var ref = this.props;
    var titles = ref.titles;
    var isItemHidden = ref.isItemHidden;
    var tabIndex = 0;

    if (!layer.children.filter(function (c) { return !isItemHidden(c); }).length) {
      // We forbid focus on keypress event for first level layers and layers without children.
      tabIndex = -1;
    }

    var inputType = layer.get('radioGroup') ? 'radio' : 'checkbox';
    return (
      // eslint-disable-next-line jsx-a11y/label-has-associated-control,jsx-a11y/no-noninteractive-element-interactions
      React.createElement( 'label', {
        className: ("rs-layer-tree-input rs-layer-tree-input-" + inputType + " rs-" + inputType), tabIndex: tabIndex, title: layer.visible ? titles.layerHide : titles.layerShow, 'aria-label': layer.visible ? titles.layerHide : titles.layerShow, onKeyPress: function (e) {
          if (e.which === 13) {
            this$1.onInputClick(layer);
          }
        } },
        React.createElement( 'input', {
          type: inputType, tabIndex: -1, checked: layer.visible, readOnly: true, onClick: function () { return this$1.onInputClick(layer); } }),
        React.createElement( 'span', null )
      )
    );
  };

  LayerTree.prototype.renderArrow = function renderArrow (layer) {
    var ref = this.props;
    var isItemHidden = ref.isItemHidden;
    var ref$1 = this.state;
    var expandedLayerNames = ref$1.expandedLayerNames;

    if (
      !layer.children.filter(function (c) { return !isItemHidden(c); }).length ||
      layer.get('isAlwaysExpanded')
    ) {
      return null;
    }

    return (
      React.createElement( 'div', {
        className: ("rs-layer-tree-arrow rs-layer-tree-arrow-" + (!expandedLayerNames.includes(layer) ? 'collapsed' : 'expanded')) })
    );
  };

  // Render a button which expands/collapse the layer if there is children
  // or simulate a click on the input otherwise.
  LayerTree.prototype.renderToggleButton = function renderToggleButton (layer) {
    var this$1 = this;

    var ref = this.props;
    var t = ref.t;
    var titles = ref.titles;
    var isItemHidden = ref.isItemHidden;
    var ref$1 = this.state;
    var expandedLayerNames = ref$1.expandedLayerNames;
    var onInputClick = function () {
      this$1.onInputClick(
        layer,
        layer.children.filter(function (c) { return !isItemHidden(c); }).length &&
          !layer.get('isAlwaysExpanded')
      );
    };
    var title = (t(layer.name)) + " " + (!expandedLayerNames.includes(layer)
        ? titles.subLayerShow
        : titles.subLayerHide);
    return (
      React.createElement( 'div', {
        role: "button", tabIndex: 0, className: "rs-layer-tree-toggle", title: title, 'aria-expanded': expandedLayerNames.includes(layer), 'aria-label': title, onClick: onInputClick, onKeyPress: onInputClick },
        React.createElement( 'div', null, t(layer.name) ),
        this.renderArrow(layer)
      )
    );
  };

  LayerTree.prototype.renderItemContent = function renderItemContent (layer) {
    return (
      React.createElement( React.Fragment, null,
        this.renderInput(layer),
        this.renderToggleButton(layer)
      )
    );
  };

  LayerTree.prototype.renderItem = function renderItem (layer, level) {
    var this$1 = this;

    var ref = this.props;
    var isItemHidden = ref.isItemHidden;
    var ref$1 = this.props;
    var renderItem = ref$1.renderItem;
    var renderItemContent = ref$1.renderItemContent;
    var renderBeforeItem = ref$1.renderBeforeItem;
    var renderAfterItem = ref$1.renderAfterItem;
    var padding = ref$1.padding;
    var getParentClassName = ref$1.getParentClassName;
    var ref$2 = this.state;
    var expandedLayerNames = ref$2.expandedLayerNames;

    var children = expandedLayerNames.includes(layer)
      ? [].concat( layer.children.filter(function (c) { return !isItemHidden(c); }) )
      : [];

    if (renderItem) {
      return renderItem(layer, this.onInputClick, this.onToggle);
    }

    return (
      React.createElement( 'div', { className: getParentClassName(), key: layer.key },
        React.createElement( 'div', {
          className: ("rs-layer-tree-item " + (layer.visible ? 'rs-visible' : '')), style: {
            paddingLeft: ((padding * level) + "px"),
          } },
          renderItemContent
            ? renderItemContent(layer, this)
            : this.renderItemContent(layer)
        ),
        renderBeforeItem && renderBeforeItem(layer, level, this),
        [].concat( children )
          .reverse()
          .map(function (child) { return this$1.renderItem(child, level + 1); }),
        renderAfterItem && renderAfterItem(layer, level, this)
      )
    );
  };

  LayerTree.prototype.renderTree = function renderTree () {
    var this$1 = this;

    var ref = this.props;
    var isItemHidden = ref.isItemHidden;
    var ref$1 = this.state;
    var layers = ref$1.layers;

    if (!layers) {
      return null;
    }

    return (
      React.createElement( React.Fragment, null,
        layers
          .filter(function (l) { return !isItemHidden(l); })
          .reverse()
          .map(function (l) { return this$1.renderItem(l, 0); })
      )
    );
  };

  LayerTree.prototype.render = function render () {
    var ref = this.props;
    var className = ref.className;
    return React.createElement( 'div', { className: className }, this.renderTree());
  };

  return LayerTree;
}(Component));

LayerTree.propTypes = propTypes;
LayerTree.defaultProps = defaultProps;

export default LayerTree;

//# sourceMappingURL=LayerTree.js.map