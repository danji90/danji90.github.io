/* eslint-disable react/jsx-props-no-spreading */
import React from 'react';
import { configure, mount } from 'enzyme';
import Adapter from 'enzyme-adapter-react-16';
import 'jest-canvas-mock';
import renderer from 'react-test-renderer';
import { Layer } from 'mobility-toolbox-js/ol';
import LayerTree from './LayerTree';
import LayerService from '../../LayerService';

configure({ adapter: new Adapter() });

var mountLayerTree = function (layers) {
  var layerService = new LayerService(layers);
  return mount(React.createElement( LayerTree, { layerService: layerService }));
};

var renderLayerTree = function (layers, props) {
  var layerService = new LayerService(layers);
  var component = renderer.create(
    React.createElement( LayerTree, Object.assign({}, { layerService: layerService }, (props || {})))
  );
  var tree = component.toJSON();
  expect(tree).toMatchSnapshot();
};

var classItem = '.rs-layer-tree-item';
var toggleItem = '.rs-layer-tree-toggle';

describe('LayerTree', function () {
  var layers;

  beforeEach(function () {
    layers = [
      new Layer({
        name: 'root',
      }),
      new Layer({
        name: '1',
        children: [
          new Layer({
            name: '1-1',
            properties: {
              radioGroup: 'radio',
            },
          }),
          new Layer({
            name: '1-2',
            properties: {
              radioGroup: 'radio',
            },
            visible: false,
            children: [
              new Layer({
                name: '1-2-1',
                visible: false,
              }),
              new Layer({
                name: '1-2-2',
                visible: false,
              }),
              new Layer({
                name: '2',
                visible: false,
              }) ],
          }) ],
      }) ];
  });
  describe('matches snapshots', function () {
    test('using default properties.', function () {
      renderLayerTree(layers);
    });

    test('when no layers.', function () {
      var layerService = new LayerService();
      var component = renderer.create(
        React.createElement( LayerTree, { layerService: layerService })
      );
      var tree = component.toJSON();
      expect(tree).toMatchSnapshot();
    });

    test('when renderItem is used.', function () {
      renderLayerTree(layers, {
        renderItem: function (item) { return React.createElement( 'div', { key: item.name }, item.name); },
      });
    });

    test('when classNames are used.', function () {
      renderLayerTree(layers, { className: 'foo' });
    });

    test('when an item is hidden.', function () {
      renderLayerTree(layers, {
        isItemHidden: function (item) { return !!item.children.length; },
      });
    });

    test('when an item is hidden (different layer tree levels)', function () {
      renderLayerTree(layers, {
        isItemHidden: function (item) { return item.isBaseLayer || item.get('hideInLegend'); },
      });
    });

    test('when an item use renderBeforeItem.', function () {
      renderLayerTree(layers, {
        renderBeforeItem: function (layer, level) { return (
          React.createElement( 'div', null, "Render name before item: ", layer.name, ", level: ", level
          )
        ); },
      });
    });

    test('when an item use renderAfterItem.', function () {
      renderLayerTree(layers, {
        renderAfterItem: function (layer, level) { return (
          React.createElement( 'div', null, "Render name after item: ", layer.name, ", level: ", level
          )
        ); },
      });
    });

    test('when items are always expanded', function () {
      var newLayers = [
        new Layer({
          name: 'Expanded layer 1 (because of level 1)',
          visible: true,
          children: [
            new Layer({
              name: 'Expanded layer 1.1 (because of isAlwaysExpanded=true)',
              visible: true,
              properties: {
                isAlwaysExpanded: true,
              },
              children: [
                new Layer({
                  name:
                    'Expanded layer 1.1.1 (because of isAlwaysExpanded=true)',
                  visible: true,
                  properties: {
                    isAlwaysExpanded: true,
                  },
                  children: [
                    new Layer({
                      name: 'Visible layer 1.1.1.1 (as parent is expanded)',
                      visible: true,
                    }) ],
                }),
                new Layer({
                  name: 'Hidden layer 1.1.1 (because of hidden=true)',
                  visible: true,
                  properties: {
                    hideInLegend: true,
                  },
                  children: [
                    new Layer({
                      name: 'Invisible layer 1.1.1.1 (as parent is hidden)',
                      visible: true,
                    }) ],
                }) ],
            }),
            new Layer({
              name: 'Expanded layer 1.2 (because of isAlwaysExpanded=true)',
              visible: true,
              properties: {
                isAlwaysExpanded: true,
              },
              children: [
                new Layer({
                  name: 'Visible layer 1.2.1 (as parent is expanded)',
                  visible: true,
                  children: [
                    new Layer({
                      name:
                        'Invisible layer 1.2.1.1 (as parent isAlwaysExpanded=false)',
                      visible: true,
                    }) ],
                }) ],
            }) ],
        }),
        new Layer({
          name: 'Expanded layer 2 (because of level 1)',
          visible: true,
          children: [
            new Layer({
              name: 'Visible layer 2.1 (as parent is expanded)',
              visible: true,
              children: [
                new Layer({
                  name:
                    'Invisible layer 2.1.1 (as parent isAlwaysExpanded=false)',
                  visible: true,
                  properties: {
                    isAlwaysExpanded: true,
                  },
                  children: [
                    new Layer({
                      name:
                        'Invisible layer 2.1.1.1 (as parent is not visible)',
                      visible: true,
                    }) ],
                }) ],
            }),
            new Layer({
              name: 'Visible layer 2.2 (as parent is expanded)',
              visible: true,
              children: [
                new Layer({
                  name:
                    'Invisible layer 2.2.1 (as parent isAlwaysExpanded=false)',
                  visible: true,
                  children: [
                    new Layer({
                      name:
                        'Invisible layer 2.2.1.1 (as parent is not visible)',
                      visible: true,
                    }) ],
                }) ],
            }) ],
        }) ];

      renderLayerTree(newLayers, {
        isItemHidden: function (item) { return item.get('hideInLegend'); },
      });
    });
  });

  describe('triggers onInputClick', function () {
    var wrapper;
    var spy;
    var spy2;
    var newLayers = [
      new Layer({
        name: 'foo',
      }) ];
    var expectCalled = function () {
      expect(spy).toHaveBeenCalledTimes(1);
      expect(spy2).toHaveBeenCalledTimes(0);
      expect(spy.mock.calls[0][0].name).toBe('foo');
    };

    beforeEach(function () {
      spy = jest.spyOn(LayerTree.prototype, 'onInputClick');
      spy2 = jest.spyOn(LayerTree.prototype, 'onToggle');
      wrapper = mountLayerTree(newLayers);
    });

    afterEach(function () {
      spy.mockRestore();
      spy2.mockRestore();
    });

    test('when we press enter with keyboard on the label element.', function () {
      wrapper.find('label').at(0).simulate('keypress', { which: 13 });
      expectCalled();
    });

    test('when we click on input.', function () {
      wrapper.find('input').at(0).simulate('click');
      expectCalled();
    });

    test('when we click on toggle button (label+arrow) of an item without children.', function () {
      wrapper.find(classItem).first().childAt(1).simulate('click');
      expectCalled();
    });
  });

  describe('triggers onToggle', function () {
    var wrapper;
    var spy;
    var newLayers = [
      new Layer({
        name: '1',
        children: [
          new Layer({
            name: '1-1',
          }),
          new Layer({
            name: '1-1-1',
          }) ],
      }) ];

    var expectCalled = function () {
      expect(spy).toHaveBeenCalledTimes(1);
    };

    beforeEach(function () {
      spy = jest.spyOn(LayerTree.prototype, 'onToggle');
      wrapper = mountLayerTree(newLayers);
    });

    test('when we click on toggle button (label+arrow) of an item with children', function () {
      wrapper.find(toggleItem).first().simulate('click');
      expectCalled();
    });
  });
});

//# sourceMappingURL=LayerTree.test.js.map