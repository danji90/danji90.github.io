import PropTypes from 'prop-types';
import React, { useMemo, useState } from 'react';
import Autosuggest from 'react-autosuggest';
import { FaSearch, FaTimes } from 'react-icons/fa';

import SearchService from './SearchService';
import StopFinder from './engines/StopFinder';

var propTypes = {
  /**
   * Flat object to provide custom search engines: key is the section and value an instance of the Engine class.
   */
  engines: PropTypes.object,

  /**
   * A function which will receive the searchService instance and needs to return a render function for the section title, see [react-autosuggest documentation](https://github.com/moroshko/react-autosuggest#render-section-title-prop) for details.
   */
  getRenderSectionTitle: PropTypes.func,

  /**
   * Initial value for the search input field.
   */
  initialValue: PropTypes.string,

  /**
   * Props for the search input field, see [react-autosuggest documentation](https://github.com/moroshko/react-autosuggest#input-props-prop) for details.
   */
  inputProps: PropTypes.object,

  /**
   * Callback function which will be called with the hovered suggestion.
   */
  onHighlight: PropTypes.func,

  /**
   * Function to define whether the suggestions are displayed or not.
   * See 'shouldRenderSuggestions' in [react-autosuggest documentation](https://github.com/moroshko/react-autosuggest#input-props-prop) for details.
   */
  shouldRenderSuggestions: PropTypes.func,

  /**
   * Callback function which will be called with the selected suggestion.
   */
  onSelect: PropTypes.func,

  /**
   * CSS class of the component.
   */
  className: PropTypes.string,

  /**
   * Key to access the engine api.
   */
  apiKey: PropTypes.string,
};

var defaultProps = {
  apiKey: null,
  engines: null,
  getRenderSectionTitle: function () { return function () { return null; }; },
  initialValue: '',
  onHighlight: function () { return null; },
  shouldRenderSuggestions: function (newValue) { return newValue.trim().length > 2; },
  onSelect: function () { return null; },
  className: 'rt-search',
  inputProps: {},
};

/**
 * The Search component renders a text input field which searches for stops
 * using the input string and centers the map on the selected stop.
 */
function Search(ref) {
  var apiKey = ref.apiKey;
  var engines = ref.engines;
  var getRenderSectionTitle = ref.getRenderSectionTitle;
  var initialValue = ref.initialValue;
  var inputProps = ref.inputProps;
  var onHighlight = ref.onHighlight;
  var shouldRenderSuggestions = ref.shouldRenderSuggestions;
  var onSelect = ref.onSelect;
  var className = ref.className;

  var currentEngines = useMemo(function () {
    if (!engines) {
      return {
        stops: new StopFinder(null, { apiKey: apiKey }),
      };
    }
    if (apiKey) {
      Object.values(engines).forEach(function (engine) {
        if (engine.setApiKey) {
          engine.setApiKey(apiKey);
        }
      });
    }
    return engines;
  }, [apiKey, engines]);

  var ref$1 = useState([]);
  var suggestions = ref$1[0];
  var setSuggestions = ref$1[1];
  var ref$2 = useState(initialValue);
  var value = ref$2[0];
  var setValue = ref$2[1];

  var searchService = useMemo(
    function () { return new SearchService({ apiKey: apiKey, engines: currentEngines, setSuggestions: setSuggestions }); },
    [apiKey, engines, setSuggestions]
  );

  var theme = useMemo(function () {
    return {
      container: (className + "__container"),
      containerOpen: (className + "__container--open"),
      input: (className + "__input"),
      inputOpen: (className + "__input--open"),
      inputFocused: (className + "__input--focused"),
      suggestionsContainer: (className + "__suggestions-container"),
      suggestionsContainerOpen: (className + "__suggestions-container--open"),
      suggestionsList: (className + "__suggestions-list"),
      suggestion: (className + "__suggestion"),
      suggestionFirst: (className + "__suggestion--first"),
      suggestionHighlighted: (className + "__suggestion--highlighted"),
      sectionContainer: (className + "__section-container"),
      sectionContainerFirst: (className + "__section-container--first"),
      sectionTitle: (className + "__section-title"),
    };
  }, [className]);

  return (
    Object.keys(currentEngines).length > 0 && (
      React.createElement( 'div', { className: "rt-search" },
        React.createElement( Autosuggest, {
          theme: theme, inputProps: Object.assign({}, {autoFocus: true,
            tabIndex: 0,
            onChange: function (e, ref) {
              var newValue = ref.newValue;

              return setValue(newValue);
  },
            onKeyUp: function (ref) {
              var key = ref.key;

              if (key === 'Enter') {
                var filtered = suggestions.filter(function (s) { return s.items.length > 0; });
                if (filtered.length > 0) {
                  var ref$1 = filtered[0];
                  var items = ref$1.items;
                  var section = ref$1.section;
                  var targetSuggestion = Object.assign({}, items[0], {section: section});
                  setValue(searchService.value(targetSuggestion));
                  onSelect(targetSuggestion);
                }
              } else if (
                (key === 'ArrowDown' || key === 'ArrowUp') &&
                typeof searchService.highlightSection === 'function'
              ) {
                searchService.highlightSection(); // for improved accessibility
              }
            },
            value: value},
            inputProps), multiSection: true, getSectionSuggestions: function (ref) {
              var items = ref.items;
              var section = ref.section;

              return items ? items.map(function (i) { return (Object.assign({}, i, {section: section})); }) : [];
  }, getSuggestionValue: function (suggestion) { return searchService.value(suggestion); }, onSuggestionsFetchRequested: function (ref) {
              var newValue = ref.value;

              return searchService.search(newValue);
  }, onSuggestionsClearRequested: function () { return setSuggestions([]); }, onSuggestionHighlighted: function (ref) {
            var suggestion = ref.suggestion;

            return onHighlight(suggestion);
  }, onSuggestionSelected: function (e, ref) {
            var suggestion = ref.suggestion;

            return onSelect(suggestion);
  }, renderSuggestion: function (suggestion) { return searchService.render(suggestion); }, renderSectionTitle: getRenderSectionTitle(searchService), shouldRenderSuggestions: function (newValue) { return shouldRenderSuggestions(newValue); }, suggestions: suggestions }),
        value && (
          React.createElement( 'button', {
            type: "button", tabIndex: 0, className: "rt-search-button rt-search-button-clear", onClick: function () { return setValue(''); } },
            React.createElement( FaTimes, null )
          )
        ),
        React.createElement( 'button', {
          type: "button", tabIndex: 0, className: "rt-search-button rt-search-button-submit" },
          React.createElement( FaSearch, { focusable: false })
        )
      )
    )
  );
}

Search.propTypes = propTypes;
Search.defaultProps = defaultProps;

export default Search;

//# sourceMappingURL=Search.js.map