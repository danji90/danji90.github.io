import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';

import OLMap from 'ol/Map';
import { transform } from 'ol/proj';
import Point from 'ol/geom/Point';
import Feature from 'ol/Feature';

import Style from 'ol/style/Style';
import Circle from 'ol/style/Circle';
import Fill from 'ol/style/Fill';
import Stroke from 'ol/style/Stroke';

import VectorLayer from 'ol/layer/Vector';
import VectorSource from 'ol/source/Vector';

import { FaRegDotCircle } from 'react-icons/fa';

var propTypes = {
  /**
   * CSS class of the button.
   */
  className: PropTypes.string,

  /**
   *  Children content of the Geolocation button.
   */
  children: PropTypes.node,

  /**
   * An [ol/map](https://openlayers.org/en/latest/apidoc/module-ol_Map-Map.html).
   */
  map: PropTypes.instanceOf(OLMap).isRequired,

  /**
   * Function triggered when geolocating is not successful.
   */
  onError: PropTypes.func,

  /**
   * If true, the map is not centered after it has been dragged once.
   */
  noCenterAfterDrag: PropTypes.bool,

  /**
   * If true, the map will constantly recenter to the current Position
   */
  alwaysRecenterToPosition: PropTypes.bool,

  /**
   * Color (Number array with rgb values) or style function.
   * If a color is given, the style is animated.
   */
  colorOrStyleFunc: PropTypes.oneOfType([
    PropTypes.arrayOf(PropTypes.number),
    PropTypes.func ]),
};

var defaultProps = {
  className: 'rs-geolocation',
  children: React.createElement( FaRegDotCircle, { focusable: false }),
  onError: function () {},
  noCenterAfterDrag: false,
  alwaysRecenterToPosition: true,
  colorOrStyleFunc: [235, 0, 0],
};

/**
 * The GeoLocation component creates a button to display the current device's location on an
 * [ol/map](https://openlayers.org/en/latest/apidoc/module-ol_Map-Map.html).
 */
var Geolocation = /*@__PURE__*/(function (PureComponent) {
  function Geolocation(props) {
    var this$1 = this;

    PureComponent.call(this, props);
    var ref = this.props;
    var map = ref.map;
    var noCenterAfterDrag = ref.noCenterAfterDrag;

    this.layer = new VectorLayer({
      source: new VectorSource(),
    });

    this.isRecenteringToPosition = true;
    if (noCenterAfterDrag) {
      map.on('pointerdrag', function () {
        this$1.isRecenteringToPosition = false;
      });
    }

    this.state = {
      active: false,
    };
    this.point = undefined;
  }

  if ( PureComponent ) Geolocation.__proto__ = PureComponent;
  Geolocation.prototype = Object.create( PureComponent && PureComponent.prototype );
  Geolocation.prototype.constructor = Geolocation;

  Geolocation.prototype.componentWillUnmount = function componentWillUnmount () {
    this.deactivate();
  };

  Geolocation.prototype.toggle = function toggle () {
    var ref = this.state;
    var active = ref.active;
    var ref$1 = this.props;
    var onError = ref$1.onError;
    var geolocation = 'geolocation' in navigator;

    if (!geolocation) {
      onError();
    } else if (!active) {
      this.activate();
    } else {
      this.deactivate();
    }
  };

  Geolocation.prototype.error = function error () {
    var ref = this.props;
    var onError = ref.onError;

    this.deactivate();
    onError();
  };

  Geolocation.prototype.deactivate = function deactivate () {
    var ref = this.props;
    var noCenterAfterDrag = ref.noCenterAfterDrag;
    window.clearInterval(this.interval);
    this.layer.setMap(null);
    navigator.geolocation.clearWatch(this.watch);

    if (!noCenterAfterDrag) {
      this.isRecenteringToPosition = true;
    }

    this.setState({
      active: false,
    });
    this.point = undefined;
  };

  Geolocation.prototype.activate = function activate () {
    var ref = this.props;
    var map = ref.map;

    this.projection = map.getView().getProjection().getCode();
    this.point = new Point([0, 0]);
    this.highlight();
    this.layer.setMap(map);
    this.setState({ active: true });

    this.watch = navigator.geolocation.watchPosition(
      this.update.bind(this),
      this.error.bind(this),
      {
        enableHighAccuracy: true,
      }
    );
  };

  Geolocation.prototype.update = function update (ref) {
    var ref_coords = ref.coords;
    var latitude = ref_coords.latitude;
    var longitude = ref_coords.longitude;

    var ref$1 = this.props;
    var map = ref$1.map;
    var alwaysRecenterToPosition = ref$1.alwaysRecenterToPosition;

    var position = transform(
      [longitude, latitude],
      'EPSG:4326',
      this.projection
    );
    this.point.setCoordinates(position);

    if (this.isRecenteringToPosition) {
      map.getView().setCenter(position);
      if (!alwaysRecenterToPosition) {
        this.isRecenteringToPosition = false;
      }
    }
  };

  Geolocation.prototype.highlight = function highlight () {
    var ref = this.props;
    var colorOrStyleFunc = ref.colorOrStyleFunc;
    var feature = new Feature({
      geometry: this.point,
    });

    if (Array.isArray(colorOrStyleFunc)) {
      var color = colorOrStyleFunc;

      var decrease = true;
      var opacity = 0.5;
      var rotation = 0;

      window.clearInterval(this.interval);
      this.interval = window.setInterval(function () {
        rotation += 0.03;
        decrease = opacity < 0.1 ? false : decrease;
        decrease = opacity > 0.5 ? true : decrease;
        opacity += decrease ? -0.03 : 0.03;
        if (feature) {
          feature.changed();
        }
      }, 50);

      feature.setStyle(function () {
        var circleStyle = new Style({
          image: new Circle({
            radius: 20,
            rotation: rotation,
            fill: new Fill({
              color: 'rgba(255, 255, 255, 0.01)',
            }),
            stroke: new Stroke({
              lineDash: [30, 10],
              width: 6,
              color: ("rgba(" + (color[0]) + ", " + (color[1]) + ", " + (color[2]) + ", " + opacity + ")"),
            }),
          }),
        });

        circleStyle.getImage().setRotation(rotation);

        return [
          new Style({
            image: new Circle({
              radius: 10,
              fill: new Fill({
                color: ("rgba(" + (color[0]) + ", " + (color[1]) + ", " + (color[2]) + ", 0.5)"),
              }),
            }),
          }),
          circleStyle ];
      });
    } else {
      feature.setStyle(colorOrStyleFunc);
    }

    this.layer.getSource().clear();
    this.layer.getSource().addFeature(feature);
  };

  Geolocation.prototype.render = function render () {
    var this$1 = this;

    var ref = this.props;
    var children = ref.children;
    var className = ref.className;
    // Remove component props from other HTML props.
    var other = Object.entries(this.props).reduce(function (props, ref) {
      var obj;

      var key = ref[0];
      var value = ref[1];
      return propTypes[key] ? props : Object.assign({}, props, ( obj = {}, obj[key] = value, obj ));
    }, {});
    var ref$1 = this.state;
    var active = ref$1.active;

    return (
      React.createElement( 'div', Object.assign({},
        { role: "button", tabIndex: "0", className: (className + " " + (active ? 'rs-active' : '')), onClick: function () { return this$1.toggle(); }, onKeyPress: function (e) { return e.which === 13 && this$1.toggle(); } }, other),
        children
      )
    );
  };

  return Geolocation;
}(PureComponent));

Geolocation.propTypes = propTypes;
Geolocation.defaultProps = defaultProps;

export default Geolocation;

//# sourceMappingURL=Geolocation.js.map