import { Component } from 'react';
import PropTypes from 'prop-types';
import qs from 'query-string';
import OLMap from 'ol/Map';
import { unByKey } from 'ol/Observable';
import LayerService from '../../LayerService';

var propTypes = {
  /**
   * Either 'react-router' history object:
   * https://github.com/ReactTraining/react-router/blob/master/packages/react-router/docs/api/history.md<br>
   * or default fallback as HTML5 History:
   * https://developer.mozilla.org/en-US/docs/Web/API/History
   */
  history: PropTypes.shape({
    replace: PropTypes.func,
  }),

  /**
   * Layers provider.
   */
  layerService: PropTypes.instanceOf(LayerService),

  /**
   * An [ol/map](https://openlayers.org/en/latest/apidoc/module-ol_Map-Map.html).
   */
  map: PropTypes.instanceOf(OLMap),

  /**
   * Params to be written in url.
   */
  params: PropTypes.object,

  /**
   * Maximum number of decimals allowed for coordinates.
   */
  coordinateDecimals: PropTypes.number,

  /**
   * Determine if the layer is hidden in the permalink or not.
   *
   * @param {object} item The item to hide or not.
   *
   * @return {bool} true if the item is not displayed in the permalink
   */
  isLayerHidden: PropTypes.func,
};

var defaultProps = {
  history: null,
  layerService: null,
  map: null,
  params: {},
  coordinateDecimals: 2,
  isLayerHidden: function () { return false; },
};

/**
 * This component handles permalink logic. Injecting an
 * __[ol/map](https://openlayers.org/en/latest/apidoc/module-ol_Map-Map.html)__
 * will add the *map center* (x, y) and the *zoom* (z) parameters to the permalink.
 * Injecting a
 * __[layerService](https://github.com/geops/react-spatial/blob/master/src/LayerService.js)__
 * (including at least one layer)
 * will add the *baselayers* and/or *layers* parameters. Further parameters can
 * be added using __params__.
 */
var Permalink = /*@__PURE__*/(function (Component) {
  function Permalink(props) {
    Component.call(this, props);
    this.state = {};
    this.moveEndRef = null;
    this.updateLayers = this.updateLayers.bind(this);
  }

  if ( Component ) Permalink.__proto__ = Component;
  Permalink.prototype = Object.create( Component && Component.prototype );
  Permalink.prototype.constructor = Permalink;

  Permalink.prototype.componentDidMount = function componentDidMount () {
    var this$1 = this;

    var ref = this.props;
    var map = ref.map;
    var layerService = ref.layerService;
    var isLayerHidden = ref.isLayerHidden;
    if (map) {
      this.moveEndRef = map.on('moveend', function () {
        this$1.onMapMoved();
      });
    }

    if (layerService) {
      this.updateLayerService();

      // set layer visibility based on 'layers' parameter.
      var urlParams = qs.parse(window.location.search);

      if (urlParams.layers) {
        var visibleLayers = urlParams.layers.split(',');
        layerService.getLayersAsFlatArray().forEach(function (l) {
          if (visibleLayers.includes(l.key)) {
            l.setVisible(true);
          } else if (
            !l.isBaseLayer &&
            !l.hasVisibleChildren() &&
            !isLayerHidden(l)
          ) {
            l.setVisible(false);
          }
        });
      }

      // Set baser layer visibility based on 'baseLayers' parameter.
      var visibleBaseLayers = (urlParams.baselayers || '').split(',');
      layerService.getBaseLayers().forEach(function (baseLayer) {
        if (baseLayer.key === visibleBaseLayers[0]) {
          baseLayer.setVisible(true); // The radio group will hide the others baseLayers automatically
        }
      });
    }
  };

  Permalink.prototype.componentDidUpdate = function componentDidUpdate (prevProps) {
    var this$1 = this;

    var ref = this.props;
    var map = ref.map;
    var layerService = ref.layerService;

    if (layerService !== prevProps.layerService) {
      this.updateLayerService();
    }

    if (map !== prevProps.map) {
      this.moveEndRef = map.on('moveend', function () { return this$1.onMapMoved(); });
    }

    this.updateHistory();
  };

  Permalink.prototype.componentWillUnmount = function componentWillUnmount () {
    var ref = this.props;
    var layerService = ref.layerService;
    var map = ref.map;

    if (map) {
      unByKey(this.moveEndRef);
    }

    if (layerService) {
      layerService.un('change:layers', this.updateLayers);
      layerService.un('change:visible', this.updateLayers);
    }
  };

  Permalink.prototype.onMapMoved = function onMapMoved () {
    var ref = this.props;
    var map = ref.map;
    var mapView = map.getView();
    var ref$1 = mapView.getProperties();
    var center = ref$1.center;

    this.setState({
      x: this.roundCoord(center[0]),
      y: this.roundCoord(center[1]),
      // rounds zoom to two digits max.
      z: +((Math.round(((parseFloat(mapView.getZoom())) + "e+2"))) + "e-2"),
    });
  };

  Permalink.prototype.roundCoord = function roundCoord (val) {
    var ref = this.props;
    var coordinateDecimals = ref.coordinateDecimals;
    return parseFloat(val.toFixed(coordinateDecimals));
  };

  Permalink.prototype.updateLayerService = function updateLayerService () {
    var ref = this.props;
    var layerService = ref.layerService;
    if (layerService) {
      layerService.un('change:visible', this.updateState);
      layerService.un('change:layers', this.updateLayers);
      this.updateLayers();
      layerService.on('change:layers', this.updateLayers);
      layerService.on('change:visible', this.updateLayers);
    }
  };

  Permalink.prototype.updateLayers = function updateLayers () {
    var ref = this.props;
    var layerService = ref.layerService;
    var isLayerHidden = ref.isLayerHidden;
    var baseLayers = layerService.getBaseLayers();
    var idx = baseLayers.findIndex(function (l) { return l.visible; });
    if (idx !== -1) {
      var baseLayerVisible = baseLayers.splice(idx, 1);
      baseLayers.unshift(baseLayerVisible[0]);
    }

    this.setState({
      layers: layerService
        .getLayersAsFlatArray()
        .filter(function (l) {
          return (
            !l.isBaseLayer &&
            l.visible &&
            !l.hasVisibleChildren() &&
            !isLayerHidden(l)
          );
        })
        .map(function (l) { return l.key; })
        .join(),
      baselayers:
        baseLayers.length > 1 ? baseLayers.map(function (l) { return l.key; }).join() : undefined,
    });
  };

  Permalink.prototype.updateHistory = function updateHistory () {
    var ref = this.props;
    var params = ref.params;
    var history = ref.history;
    var oldParams = qs.parse(window.location.search);
    var parameters = Object.assign({}, oldParams, params, this.state);
    // encodeURI to encode spaces, accents, etc. but not characters like ;,/?:@&=+$-_.!~*'()
    var qStr = encodeURI(qs.stringify(parameters, { encode: false }));
    var search = qStr ? ("?" + qStr) : '';

    if (
      (!qStr && window.location.search) ||
      (qStr && search !== window.location.search)
    ) {
      if (history) {
        history.replace({ search: search });
      } else {
        var ref$1 = window.location;
        var hash = ref$1.hash;
        window.history.replaceState(
          undefined,
          undefined,
          ("" + search + (hash || ''))
        );
      }
    }
  };

  Permalink.prototype.render = function render () {
    return null;
  };

  return Permalink;
}(Component));

Permalink.propTypes = propTypes;
Permalink.defaultProps = defaultProps;

export default Permalink;

//# sourceMappingURL=Permalink.js.map