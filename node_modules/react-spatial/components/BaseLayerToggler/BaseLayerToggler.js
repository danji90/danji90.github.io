import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { FaArrowCircleLeft, FaArrowCircleRight } from 'react-icons/fa';
import OLMap from 'ol/Map';
import { unByKey } from 'ol/Observable';
import TileLayer from 'ol/layer/Tile';
import { containsExtent } from 'ol/extent';
import LayerService from '../../LayerService';
import BasicMap from '../BasicMap';

var propTypes = {
  /**
   * An [ol/map](https://openlayers.org/en/latest/apidoc/module-ol_Map-Map.html)
   */
  map: PropTypes.instanceOf(OLMap).isRequired,

  /**
   * LayerService.
   */
  layerService: PropTypes.instanceOf(LayerService),

  /**
   * CSS class to apply on the container.
   */
  className: PropTypes.string,

  /**
   * Children of the previous baselayer button.
   */
  prevButtonContent: PropTypes.node,

  /**
   * Children of the next baselayer button.
   */
  nextButtonContent: PropTypes.node,

  /**
   * Path to the directory which includes the fallback images
   */
  fallbackImgDir: PropTypes.string,

  /**
   * Outside of this valid extent the fallback image is loaded
   */
  validExtent: PropTypes.arrayOf(PropTypes.number),

  /**
   * Button titles.
   */
  titles: PropTypes.shape({
    button: PropTypes.string,
    prevButton: PropTypes.stirng,
    nextButton: PropTypes.string,
  }),
};

var defaultProps = {
  layerService: undefined,
  className: 'rs-base-layer-toggler',
  prevButtonContent: React.createElement( FaArrowCircleLeft, { focusable: false }),
  nextButtonContent: React.createElement( FaArrowCircleRight, { focusable: false }),
  fallbackImgDir: '../../images/baselayer/',
  validExtent: [-Infinity, -Infinity, Infinity, Infinity],
  titles: {
    button: 'Toggle base layer',
    nextButton: 'Next base layer',
    prevButton: 'Previous base layer',
  },
};

/**
 * The BaseLayerToggler component renders a button interface for switching the visible
 * [mobility-toolbox-js layer](https://mobility-toolbox-js.geops.io/api/identifiers%20html#ol-layers)
 * when defined as base layer.
 */
var BaseLayerToggler = /*@__PURE__*/(function (Component) {
  function BaseLayerToggler(props) {
    Component.call(this, props);
    this.state = {
      layers: null,
      layerVisible: null,
      idx: 0,
      fallbackImg: null,
      fallbackImgOpacity: 0,
    };
    this.map = null;
    this.ref = React.createRef();

    this.updateState = this.updateState.bind(this);
    this.resetState = this.resetState.bind(this);
  }

  if ( Component ) BaseLayerToggler.__proto__ = Component;
  BaseLayerToggler.prototype = Object.create( Component && Component.prototype );
  BaseLayerToggler.prototype.constructor = BaseLayerToggler;

  BaseLayerToggler.isDifferentLayers = function isDifferentLayers (prevLayers, layers) {
    if (prevLayers && layers) {
      return (
        JSON.stringify(prevLayers.map(function (l) { return l.key; })) !==
        JSON.stringify(layers.map(function (l) { return l.key; }))
      );
    }
    return false;
  };

  BaseLayerToggler.prototype.componentDidMount = function componentDidMount () {
    var ref = this.props;
    var layerService = ref.layerService;
    var map = ref.map;

    if (layerService) {
      this.updateLayerService();
    }

    if (map) {
      this.updateMap();
    }
  };

  BaseLayerToggler.prototype.componentDidUpdate = function componentDidUpdate (prevProps, prevState) {
    var this$1 = this;

    var ref = this.props;
    var layerService = ref.layerService;
    var map = ref.map;
    var ref$1 = this.state;
    var layerVisible = ref$1.layerVisible;
    var idx = ref$1.idx;
    var layers = ref$1.layers;

    if (layerService !== prevProps.layerService) {
      this.updateLayerService();
    }

    if (map !== prevProps.map) {
      this.updateMap();
    }

    if (layerVisible && !prevState.layerVisible) {
      this.next();
    } else if (
      layerVisible !== prevState.layerVisible &&
      layers.includes(prevState.layerVisible)
    ) {
      // In case the visibility of the background Layer is change from another component.
      this.toggle(prevState.layerVisible);
    }

    if (
      this.map &&
      (idx !== prevState.idx ||
        BaseLayerToggler.isDifferentLayers(prevState.layers, layers))
    ) {
      this.map.getLayers().clear();

      if (!layers.length) {
        return;
      }
      var children = [];
      var childLayers = [];
      if (idx !== null && idx < layers.length) {
        children = layers[idx].children;
        childLayers = children.length ? children : [layers[idx]];
      }

      childLayers.forEach(function (layer) {
        if (layer.clone) {
          var ml;
          // MapboxStyleLayer
          if (layer.mapboxLayer) {
            ml = layer.mapboxLayer.clone();
            ml.init(this$1.map); // Including addLayer
            ml.setVisible(true);
          }
          var cloned = layer.clone(ml);
          cloned.init(this$1.map); // Including addLayer
          cloned.setVisible(true);
        } else if (layer.olLayer && layer.olLayer instanceof TileLayer) {
          this$1.map.addLayer(
            new TileLayer({
              source: layer.olLayer.getSource(),
            })
          );
        }
        this$1.checkExtent();
      });
    }
  };

  BaseLayerToggler.prototype.componentWillUnmount = function componentWillUnmount () {
    var ref = this.props;
    var layerService = ref.layerService;
    unByKey([this.postRenderKey, this.moveEndKey]);
    layerService.un('change:visible', this.updateState);
    layerService.un('change:layers', this.resetState);
  };

  BaseLayerToggler.prototype.setNextVisible = function setNextVisible (nextLayer) {
    var ref = this.state;
    var layers = ref.layers;
    // Unset visibility to all layers before showing the next layer.
    layers.forEach(function (l) { return l.visible && l.setVisible(false, true, true, true); });
    nextLayer.setVisible(true);
  };

  BaseLayerToggler.prototype.updateLayerService = function updateLayerService () {
    var ref = this.props;
    var layerService = ref.layerService;

    if (!layerService) {
      return;
    }
    layerService.un('change:visible', this.updateState);
    layerService.un('change:layers', this.resetState);
    this.updateState();
    layerService.on('change:visible', this.updateState);
    layerService.on('change:layers', this.resetState);
  };

  BaseLayerToggler.prototype.updateState = function updateState (evtLayer) {
    if (evtLayer && !evtLayer.isBaseLayer) {
      return;
    }

    var ref = this.props;
    var layerService = ref.layerService;
    var ref$1 = this.state;
    var idx = ref$1.idx;

    var layers = layerService.getBaseLayers() || [];
    var newIdx = idx;
    if (newIdx === -1 && layers.length > 1) {
      newIdx = 0;
      layers[idx].setVisible(true);
    }

    this.setState({
      layers: layers,
      idx: newIdx,
      layerVisible: layers.length > 1 ? layers[newIdx] : null,
    });
  };

  BaseLayerToggler.prototype.resetState = function resetState () {
    var ref = this.props;
    var layerService = ref.layerService;
    var ref$1 = this.state;
    var layerVisible = ref$1.layerVisible;

    var layers = layerService.getBaseLayers() || [];
    var idx = layerVisible ? layers.indexOf(layerVisible) : -1;
    var newIdx;

    if (idx === -1) {
      newIdx = 1;
    } else if (idx === layers.length - 1) {
      newIdx = 0;
    } else {
      newIdx = idx + 1;
    }

    var newLayerVisible = layers[idx === -1 ? 0 : idx];
    this.setState({
      layers: layers,
      idx: layers.length > 1 ? newIdx : null,
      layerVisible:
        layers.indexOf(newLayerVisible) >= 0 ? newLayerVisible : undefined,
    });
  };

  BaseLayerToggler.prototype.updateMap = function updateMap () {
    var this$1 = this;

    var ref = this.props;
    var map = ref.map;
    if (!this.map) {
      this.map = new OLMap({ controls: [], interactions: [] });
    }
    unByKey([this.postRenderKey, this.moveEndKey]);
    this.postRenderKey = map.on('postrender', function (e) {
      this$1.map.getView().setZoom(e.target.getView().getZoom());
      if (this$1.ref && this$1.ref.current) {
        var elt = this$1.ref.current;
        var coord = map.getCoordinateFromPixel([
          elt.offsetLeft + elt.offsetWidth / 2,
          elt.offsetTop + elt.offsetHeight / 2 ]);

        // In some case the map is not able to get the coord.
        // For example if the map has a width or height of 0.
        if (!coord) {
          return;
        }

        this$1.map.getView().setCenter(coord);
      }
    });

    this.moveEndKey = map.on('moveend', function () {
      this$1.checkExtent();
    });
  };

  BaseLayerToggler.prototype.toggle = function toggle (layer) {
    var ref = this.state;
    var layers = ref.layers;

    var index = 0;
    while (layer !== layers[index]) {
      index += 1;
    }

    this.setState({
      idx: index,
    });
  };

  BaseLayerToggler.prototype.previous = function previous () {
    var ref = this.state;
    var layers = ref.layers;
    var layerVisible = ref.layerVisible;
    var idx = ref.idx;
    var previousIdx = idx - 1;

    while (!layers[previousIdx] || layerVisible === layers[previousIdx]) {
      previousIdx -= 1;
      if (previousIdx < 0) {
        previousIdx = layers.length - 1;
      }
    }

    this.setState({
      idx: previousIdx,
    });
  };

  BaseLayerToggler.prototype.next = function next () {
    var ref = this.state;
    var layers = ref.layers;
    var layerVisible = ref.layerVisible;
    var idx = ref.idx;
    var nextIdx = idx + 1;

    while (!layers[nextIdx] || layerVisible === layers[nextIdx]) {
      nextIdx += 1;
      if (nextIdx >= layers.length) {
        nextIdx = 0;
      }
    }

    this.setState({
      idx: nextIdx,
    });
  };

  /**
   * Check if the next layer is inside the global extent.
   * If not, try setting a global image.
   */
  BaseLayerToggler.prototype.checkExtent = function checkExtent () {
    var ref = this.props;
    var validExtent = ref.validExtent;
    var map = ref.map;
    var fallbackImgDir = ref.fallbackImgDir;
    var ref$1 = this.state;
    var idx = ref$1.idx;
    var layers = ref$1.layers;
    var fallbackImg = ref$1.fallbackImg;
    var nextLayer = layers[idx];
    var opacity = 0;
    var img = fallbackImg;

    if (validExtent && this.ref && this.ref.current && nextLayer) {
      var elt = this.ref.current;
      var blCoord = map.getCoordinateFromPixel([
        elt.offsetLeft,
        elt.offsetTop + elt.offsetHeight ]);
      var trCoord = map.getCoordinateFromPixel([
        elt.offsetLeft + elt.offsetWidth,
        elt.offsetTop ]);

      if (!blCoord || !trCoord) {
        return;
      }

      if (!containsExtent(validExtent, blCoord.concat( trCoord))) {
        opacity = 1;
        img = "" + fallbackImgDir + (nextLayer.key) + ".png";
      }
    }

    this.setState({
      fallbackImg: img,
      fallbackImgOpacity: opacity,
    });
  };

  BaseLayerToggler.prototype.render = function render () {
    var this$1 = this;

    var ref = this.props;
    var className = ref.className;
    var titles = ref.titles;
    var prevButtonContent = ref.prevButtonContent;
    var nextButtonContent = ref.nextButtonContent;
    var ref$1 = this.state;
    var layers = ref$1.layers;
    var idx = ref$1.idx;
    var fallbackImg = ref$1.fallbackImg;
    var fallbackImgOpacity = ref$1.fallbackImgOpacity;

    var footer = null;

    if (!layers || layers.length < 2) {
      return null;
    }

    if (layers.length > 2) {
      footer = (
        React.createElement( 'div', { className: "rs-base-layer-footer" },
          React.createElement( 'div', {
            className: "rs-base-layer-previous", role: "button", onClick: function () { return this$1.previous(); }, onKeyPress: function (e) { return e.which === 13 && this$1.previous(); }, tabIndex: "0", 'aria-label': titles.prevButton, title: titles.prevButton },
            prevButtonContent
          ),
          React.createElement( 'div', {
            className: "rs-base-layer-next", role: "button", onClick: function () { return this$1.next(); }, onKeyPress: function (e) { return e.which === 13 && this$1.next(); }, tabIndex: "0", 'aria-label': titles.nextButton, title: titles.nextButton },
            nextButtonContent
          )
        )
      );
    }

    var nextLayer = layers[idx];

    return (
      React.createElement( 'div', { className: className, ref: this.ref },
        React.createElement( 'div', {
          className: "rs-base-layer-toggle-button", role: "button", title: titles.button, 'aria-label': titles.button, onClick: function () { return this$1.setNextVisible(nextLayer); }, onKeyPress: function (e) { return e.which === 13 && this$1.setNextVisible(nextLayer); }, tabIndex: "0" },
          React.createElement( 'img', {
            src: fallbackImg, alt: fallbackImg, style: { opacity: fallbackImgOpacity }, className: "rs-base-layer-image" }),
          React.createElement( BasicMap, {
            map: this.map, className: "rs-base-layer-map", tabIndex: -1 })
        ),
        footer
      )
    );
  };

  return BaseLayerToggler;
}(Component));

BaseLayerToggler.propTypes = propTypes;
BaseLayerToggler.defaultProps = defaultProps;

export default BaseLayerToggler;

//# sourceMappingURL=BaseLayerToggler.js.map