import React, { useMemo, useState, useEffect } from 'react';
import PropTypes from 'prop-types';
import { Autocomplete } from '@material-ui/lab';
import { FaSearch } from 'react-icons/fa';
import TextField from '@material-ui/core/TextField';
import CircularProgress from '@material-ui/core/CircularProgress';
import StopsFinderControl from 'mobility-toolbox-js/ol/controls/StopsFinderControl';
import { Map } from 'ol';
import { makeStyles } from '@material-ui/core';
import StopsFinderOptions from './StopsFinderOption';

var useStyles = makeStyles(function () {
  return {
    popupIndicatorOpen: {
      transform: 'rotate(0)',
    },
  };
});

function StopsFinder(ref) {
  var agencies = ref.agencies;
  var apiKey = ref.apiKey;
  var autocompleteProps = ref.autocompleteProps;
  var bbox = ref.bbox;
  var field = ref.field;
  var limit = ref.limit;
  var map = ref.map;
  var mots = ref.mots;
  var onSelect = ref.onSelect;
  var radius = ref.radius;
  var refLocation = ref.refLocation;
  var renderAutocomplete = ref.renderAutocomplete;
  var url = ref.url;

  var classes = useStyles();
  var ref$1 = useState('');
  var inputValue = ref$1[0];
  var setInputValue = ref$1[1];
  var ref$2 = useState([]);
  var suggestions = ref$2[0];
  var setSuggestions = ref$2[1];
  var ref$3 = useState(false);
  var isLoading = ref$3[0];
  var setLoading = ref$3[1];
  var ref$4 = useState(false);
  var isOpen = ref$4[0];
  var setOpen = ref$4[1];

  var control = useMemo(function () {
    return new StopsFinderControl({
      url: url,
      apiKey: apiKey,
      target: document.createElement('div'),
      element: document.createElement('div'),
      render: function render(newSuggestions) {
        if ( newSuggestions === void 0 ) newSuggestions = [];

        setSuggestions(newSuggestions);
        setLoading(false);
      },
    });
  }, [apiKey, url]);

  useEffect(function () {
    if (!inputValue) {
      setSuggestions([]);
      setLoading(false);
      return function () {};
    }
    var abortController = new AbortController();
    setLoading(true);
    control.apiParams = {
      prefAgencies: agencies && agencies.toString(),
      bbox: bbox && bbox.toString(),
      field: field && field.toString(),
      limit: limit,
      mots: mots && mots.toString(),
      radius: radius,
      ref_location: refLocation && refLocation.toString(),
    };
    control.search(inputValue, abortController);
    return function () {
      abortController.abort();
    };
  }, [
    agencies,
    bbox,
    control,
    field,
    inputValue,
    limit,
    mots,
    radius,
    refLocation ]);

  // Ensure the control is not associated to the wrong map
  useEffect(function () {
    if (!control) {
      return function () {};
    }

    control.map = map;

    return function () {
      control.map = null;
    };
  }, [map, control]);

  if (!control) {
    return null;
  }

  if (renderAutocomplete) {
    return renderAutocomplete(
      suggestions,
      inputValue,
      setInputValue,
      isOpen,
      setOpen,
      isLoading,
      setLoading
    );
  }

  return (
    React.createElement( Autocomplete, Object.assign({},
      { fullWidth: true, autoComplete: true, autoHighlight: true, selectOnFocus: true, getOptionLabel: function (option) { return option.properties.name; }, onChange: function (evt, value, reason) {
        if (onSelect && reason === 'select-option') {
          onSelect(value, evt);
        }
      }, popupIcon: React.createElement( FaSearch, { focusable: false, size: 15 }), renderInput: function (params) {
        return (
          React.createElement( TextField, Object.assign({},
            { label: "Search stops" }, Object.assign({}, params,
              ((autocompleteProps || {}).textFieldProps || {})), { InputProps: Object.assign({}, params.InputProps,
              {endAdornment: (
                React.createElement( React.Fragment, null,
                  isLoading && React.createElement( CircularProgress, { size: 20 }),
                  params.InputProps.endAdornment
                )
              )}) }))
        );
      }, renderOption: function (option) {
        return React.createElement( StopsFinderOptions, { option: option });
      } }, Object.assign({}, autocompleteProps, {textFieldProps: null}), { classes: Object.assign({}, classes, autocompleteProps.classes), inputValue: inputValue, open: isOpen, options: suggestions, loading: isLoading, onOpen: function () {
        setOpen(true);
      }, onClose: function () {
        setOpen(false);
      }, onInputChange: function (evt, val) {
        setInputValue(val);
      } }))
  );
}

StopsFinder.propTypes = {
  /**
   * Array or a comma separated list of agencies which should be available.
   * Order of these agencies chooses which agency will be preferred.
   * Available values : sbb, db
   */
  agencies: PropTypes.oneOfType([
    PropTypes.string,
    PropTypes.arrayOf(PropTypes.string) ]),

  /**
   * geOps api key to access the StopsFinder service.
   */
  apiKey: PropTypes.string,

  /**
   * Properties apply to the default [MUI Autocomplete component](https://material-ui.com/api/autocomplete/).
   * We add a custom properties textFieldProps for the default [MUI TextField component](https://material-ui.com/api/text-field/) used by the Autocomplete.
   */
  autocompleteProps: PropTypes.object,

  /**
   * minX,minY,maxX,maxY coordinates in WGS84 wherein the station should lie.
   */
  bbox: PropTypes.oneOfType([
    PropTypes.string,
    PropTypes.arrayOf(PropTypes.number) ]),

  /**
   * Array or a comma separated list of fields which should be used for look up.
   * Available values : id, name, coords
   */
  field: PropTypes.oneOfType([
    PropTypes.string,
    PropTypes.arrayOf(PropTypes.string) ]),

  /**
   * Control how many matches will be returned.
   */
  limit: PropTypes.number,

  /**
   * A map.
   */
  map: PropTypes.instanceOf(Map).isRequired,

  /**
   * Array or a comma separated list of mode of transpaorts which should be available.
   * Available values : bus, ferry, gondola, tram, rail, funicular, cable_car, subway
   */
  mots: PropTypes.oneOfType([
    PropTypes.string,
    PropTypes.arrayOf(PropTypes.string) ]),

  /**
   * Function called when a suggestion is selected.
   */
  onSelect: PropTypes.func,

  /**
   * Radius around refLocation in meters that is most relevant.
   * Used as granularity for location rank.
   */
  radius: PropTypes.number,

  /**
   * Coordinates in WGS84 (in lat,lon order) used to rank stops close to this position higher.
   * Available values : id, name, coords
   */
  refLocation: PropTypes.oneOfType([
    PropTypes.string,
    PropTypes.arrayOf(PropTypes.number) ]),

  /**
   * Function to render a different autocomplete input than the default one.
   */
  renderAutocomplete: PropTypes.func,

  /**
   * Url of the geOps StopsFinder service.
   */
  url: PropTypes.string,
};

StopsFinder.defaultProps = {
  agencies: null,
  apiKey: null,
  autocompleteProps: {},
  bbox: null,
  field: null,
  limit: null,
  mots: null,
  onSelect: null,
  radius: null,
  refLocation: null,
  url: null,
  renderAutocomplete: null,
};

export default StopsFinder;

//# sourceMappingURL=StopsFinder.js.map